{"meta":{"title":"邱雪雁的blog","subtitle":"","description":"","author":"YukiXueyan","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-05-04T09:45:29.000Z","updated":"2021-05-04T09:46:52.820Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"about yuki"},{"title":"书单","date":"2021-05-04T10:48:45.532Z","updated":"2021-05-04T10:48:45.532Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-05-04T10:48:45.533Z","updated":"2021-05-04T10:48:45.533Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-05-04T10:48:45.533Z","updated":"2021-05-04T10:48:45.533Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-05-04T11:16:46.568Z","updated":"2021-05-04T11:16:46.568Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":"github: username: YukiXueyan"},{"title":"标签","date":"2021-05-05T06:18:23.275Z","updated":"2021-05-05T06:18:23.275Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于我用过的那些hexo主题","slug":"hexo主题推荐","date":"2021-05-04T11:22:49.000Z","updated":"2021-05-11T15:23:41.596Z","comments":true,"path":"2021/05/04/hexo主题推荐/","link":"","permalink":"http://example.com/2021/05/04/hexo%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90/","excerpt":"","text":"purepure也就是我现在正在用的主题啦。三栏式布局非常简单，一目了然。可以直观看到文章、分类、标签等。配置也很方便。同时也支持各种插件，让博客具有更多功能。 项目地址 主题预览 3-hexo三段式页面，分为导览、文章列表、正文内容三个部分。 项目地址 主题预览 matery这个主题有明亮多彩的颜色，置于顶部的菜单栏。对自定义样式的支持十分友好。进入界面就是一个很大的壁纸，可以设置格言、推荐文章之类。瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替）也很特别。 项目地址 主题预览 yun一个特别可爱的主题。蓝白的设计很简洁。整体色调比较统一。也是两栏式的布局。在进入界面时也会展示一页的格言之类。鼠标点击可以产生特效。还有夜间模式。重点是它很轻量，加载速度挺快的！项目地址 主题预览 以上是我用过的且印象比较深刻的hexo主题啦。每次换新主题就像买到好看的新衣服一样。不同的主题各有各的漂亮~","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"YukiXueyan"},{"title":"【Android】使用recyclerView+adapter实现滑动布局，并添加点击和长按事件","slug":"【Android】使用recyclerView-adapter实现滑动布局，并添加点击和长按事件","date":"2021-05-04T05:08:26.000Z","updated":"2021-05-05T06:13:11.317Z","comments":true,"path":"2021/05/04/【Android】使用recyclerView-adapter实现滑动布局，并添加点击和长按事件/","link":"","permalink":"http://example.com/2021/05/04/%E3%80%90Android%E3%80%91%E4%BD%BF%E7%94%A8recyclerView-adapter%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E5%B8%83%E5%B1%80%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E5%92%8C%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"本文基于《第一行代码（第三版）》，记录一下使用kotlin语言建立recyclerView+adapter的滑动布局，并在adapter中设定监听器，已达到在Activity中使用adapter时自主设定点击和长按事件。 新建fruit类、fruit的布局 fruit类 1class Fruit(val name:String, val bitmap: Bitmap) 自定义布局 1234567891011121314151617181920&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/fruitImage&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot;/&gt; &lt;TextView android:id=&quot;@+id/fruitName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; /&gt;&lt;/LinearLayout&gt; 定义adapter适配器及监听接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.example.adaptertestimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.ImageViewimport android.widget.TextViewimport androidx.recyclerview.widget.RecyclerViewclass FruitAdapter(val fruitsList: List&lt;Fruit&gt;): RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;()&#123; inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view)&#123; val fruitView = view val fruitImage : ImageView = view.findViewById(R.id.fruitImage) val fruitName : TextView = view.findViewById(R.id.fruitName) &#125; //此处设置监听器 interface OnItemClickListener &#123; fun onItemClick(view: View?, position: Int) //点击监听 fun onItemLongClick(view: View?, position: Int)//长按监听 &#125; //调用监听器 private var onItemClickListener: OnItemClickListener? = null fun setOnItemClickListener(onItemClickListener: OnItemClickListener?) &#123; this.onItemClickListener = onItemClickListener &#125; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123; val view = LayoutInflater.from(parent.context).inflate(R.layout.fruit_item, parent, false) val viewHolder = ViewHolder(view)// viewHolder.fruitImage.setOnClickListener &#123;&#125; return ViewHolder(view) &#125; override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; val fruit = fruitsList[position] holder.fruitImage.setImageBitmap(fruit.imgBitmap) holder.fruitName.text = fruit.name //设置监听器 if (onItemClickListener != null) &#123; holder.fruitView.setOnClickListener &#123; val layoutPos = holder.layoutPosition onItemClickListener!!.onItemClick(holder.fruitView, layoutPos) &#125; holder.fruitView.setOnLongClickListener &#123; val layoutPos = holder.layoutPosition onItemClickListener!!.onItemLongClick(holder.fruitView, layoutPos) false &#125; &#125; &#125; override fun getItemCount() = fruitsList.size&#125; 在Activity里使用recyclerView12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MainActivity : AppCompatActivity() &#123; private val fruitList = ArrayList&lt;Fruit&gt;() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initFruits() // 初始化水果数据 val layoutManager = LinearLayoutManager(this) recyclerView.layoutManager = layoutManager val adapter = FruitAdapter(fruitList) recyclerView.adapter = adapter adapter.setOnItemClickListener(object : FruitAdapter.OnItemClickListener&#123; override fun onItemClick(view: View?, position: Int) &#123; //定义点击事件 Toast.makeText(this@MainActivity,&quot;点击事件&quot;, Toast.LENGTH_SHORT).show() &#125; override fun onItemLongClick(view: View?, position: Int) &#123; //定义长按事件 Toast.makeText(this@MainActivity,&quot;长按事件&quot;, Toast.LENGTH_SHORT).show() //删除示例 fruitList.removeAt(position) adapter.notifyDataSetChanged() &#125; &#125;) &#125; private fun initFruits() &#123; repeat(2) &#123; fruitList.add(Fruit(&quot;Apple&quot;, R.drawable.apple_pic)) fruitList.add(Fruit(&quot;Banana&quot;, R.drawable.banana_pic)) fruitList.add(Fruit(&quot;Orange&quot;, R.drawable.orange_pic)) fruitList.add(Fruit(&quot;Watermelon&quot;, R.drawable.watermelon_pic)) fruitList.add(Fruit(&quot;Pear&quot;, R.drawable.pear_pic)) fruitList.add(Fruit(&quot;Grape&quot;, R.drawable.grape_pic)) fruitList.add(Fruit(&quot;Pineapple&quot;, R.drawable.pineapple_pic)) fruitList.add(Fruit(&quot;Strawberry&quot;, R.drawable.strawberry_pic)) fruitList.add(Fruit(&quot;Cherry&quot;, R.drawable.cherry_pic)) fruitList.add(Fruit(&quot;Mango&quot;, R.drawable.mango_pic)) &#125; &#125;&#125; 改变recyclerView的布局为横向排布或网格排布","categories":[{"name":"android","slug":"android","permalink":"http://example.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://example.com/tags/android/"}],"author":"YukiXueyan"},{"title":"0331面试总结","slug":"0331面试总结","date":"2021-03-31T09:39:25.000Z","updated":"2021-03-31T10:13:00.903Z","comments":true,"path":"2021/03/31/0331面试总结/","link":"","permalink":"http://example.com/2021/03/31/0331%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"总的来说，面试也是对自己能力的一个检验吧，今天一共有3场面试，强度还是比较大。虽然面试之前比较紧张&gt; &lt; 下面是一些面试中提到的问题总结： 美团 65min美团的面试有一些手写代码的环节，所以需要掌握代码的实现才不会拉跨。问到的一些问题有： 响应式概述 eventloop css的布局有哪些 css的浮动取值和position取值等布局方式 提到了微信小程序，问了微信小程序的单位rpx 两栏布局的实现方式有哪些，说得越多越好 面向对象的三大特征 接口是什么 闭包是什么 手写一个函数，传入一个函数和数字num，实现只调用num次这个数字（就是使用闭包来实现） 12345678910111213141516171819//例：实现wrapper(a,num)：wrapper(a,2);wrapper(a,2);wrapper(a,2);wrapper(a,2);虽然调用4次wrapper(),最终只调用a() 2次解答：function wrapper(fn,num)&#123; let count = 0 return funtion()&#123; if(count&gt;num)&#123; return; &#125; fn(); count++; &#125;&#125; 还写了一个URL截取 问到了使用vue和原生js的区别 最后就是部门介绍和反问环节啦 腾讯40min 自我介绍和项目介绍 了解断点续传吗 vue的生命周期 vue的响应式的实现原理 js的变量提升 js的作用域有哪些，具体解释一下 解释一下闭包 this的四种绑定 new和硬绑定的优先级 HTTP和HTTPS有了解吗 SSL的实现方式，是对称加密还是非对称加密？ css的盒模型 CSS的选择器有哪些，以及选择器的优先级 跨域有了解吗 反问环节~ 阿里40min阿里的话已经是技术主管面了，所以没有问到经典的基础题目，基本上都是围绕着项目来问的。问了项目的实现、项目的难点和解决方法。因为我的项目用到了vue，提到了单页面，所以面试官有问到单页面和多页面之间的不同以及基本的实现原理、单页面的优势等。还有vue的响应式实现原理之类。我当时想到的是重绘与排。多页面的话，在进行页面跳转时就需要获取不同的HTML文件，在页面上进行渲染。而单页面的话就是一个HTML，加上各种vue组件。要进行不同功能的改变的话就只需要加载组件即可，不需要重新渲染一整个界面。 还有问到前后端分离的方法以及域名加载这些。单页面和多页面的域名会有什么样的不同。 别的还有一些开放题，比如说学习前端的方法，怎么分配时间，有没有读研的打算等等。问到了有没有去看GitHub和别人的博客去学习，学到了什么东西，在项目上怎么使用之类…这个应该还是需要前期做好一些准备才不会在面试时给自己挖坑。 最后还有问到对要面试的部门以及部门主要业务的一些了解。我有回答阿里云的服务器以及开放的api这些。hr问了我，作为一个用户的角度去评价一下阿里云的服务.。这个当时还是有点懵…… 许愿offer！ 最后总结面试还是基础和项目两手都要准备。说出的每一句话都可能被问到，所以发言前一定要斟酌好！以及…基础要特别熟悉起来！","categories":[],"tags":[]},{"title":"图解HTTP","slug":"图解HTTP","date":"2021-03-21T13:47:19.000Z","updated":"2021-03-21T14:05:16.083Z","comments":true,"path":"2021/03/21/图解HTTP/","link":"","permalink":"http://example.com/2021/03/21/%E5%9B%BE%E8%A7%A3HTTP/","excerpt":"","text":"1 了解web及网络基础1.3 通常使用的网络是在TCP/IP协议族的基础上运作的，HTTP是内部的一个子集。 TCP/IP协议族分4个层次：应用层、传输层、网络层、链路层。 应用层：决定向用户提供应用服务通信时的活动。 FTP（文件传输协议）、DNS（域名解析服务）、HTTP协议 传输层：提供两台计算机的数据传输 TCP、UDP 网络层：处理网络上流动的数据包 链路层：处理硬件部分。 发送端从应用层往下走，接收端从应用层往上走。发送端每次通过一层就增加首部、接收端通过一层就删除首部。 IP：位于网络层，作用是把各种数据包传送给对方。指明了MAC地址。 解析MAC地址用到ARP协议。 TCP：提供可靠的字节流服务。将大块的报文切割为报文段。 确认数据是否到达的标志：SYN、ACK 三次握手： 四次挥手 DNS：负责解析域名。提供域名到IP地址之间的解析服务。 2 简单的HTTP协议3 HTTP报文内部的HTTP信息4 返回结果状态的HTTP状态码5 与HTTP协作的web服务器6 HTTP首部7 确保web安全的HTTPS8 确认访问用户身份的认证9 基于HTTP的功能追加协议10 构建web内容的技术11 web的攻击技术","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"YukiXueyan"},{"title":"ES6学习笔记","slug":"ES6学习笔记","date":"2021-03-15T12:58:45.000Z","updated":"2021-03-16T08:28:15.286Z","comments":true,"path":"2021/03/15/ES6学习笔记/","link":"","permalink":"http://example.com/2021/03/15/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"今天看的是这个ES6入门文档,很详细地讲解了ES6.未来再看阮一峰的ECMAScript教程作为补充吧ECMAScript是JavaScript的规格，JavaScript是ECMAscript的实现。 部署： 使用node.js Babel转码器： 广泛使用的ES6转码器，可将ES6转化为ES5，从而在现有环境中进行。 Babel配置文件是.babelrc，用于设置转码规则和插件 命令行转码工具：babel-cli babel-node直接运行ES6代码 Traceur转码器，也可以将ES6转为ES5 let和constlet所声明的变量只在所在的代码块内有效。适合在for循环内使用，避免值覆盖的情况。 12345678910111213141516var a=[];for (var i=0;i&lt;10;i++)&#123;a[i] = function()&#123;console.log(i);&#125;;&#125;a[6];//10var a=[];for (let i=0;i&lt;10;i++)&#123;a[i] = function()&#123;console.log(i);&#125;;&#125;a[6];//6 let 不存在变量提升，因此一定要先声明变量才能使用。var存在变量提升。 暂时性死区一旦区块中存在let和const变量，就一定要先声明再使用。凡是在声明之前使用这些变量，就会报错。哪怕已经有一个var声明的全局变量。 用let声明的变量，在声明之前都是该变量的死区，用到就会报错。 暂时性死区的本质：已进入当前作用域，要使用的 变量就已经存在，但是不可获取。只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 let不允许在同一作用域内重复声明变量。 块级作用域外层代码块不受内层代码块的影响。 外层作用域无法读取内层作用域的变量。 内层作用域可以定义外层作用域的同名变量。 ES5中函数只能在顶层作用域和函数作用域中声明，不能在块级作用域声明。ES6允许在块级作用域中声明函数。 const声明的变量不能改变值，const一旦声明变量，就必须立刻初始化，不能留到最后赋值。 const声明的变量只在块级作用域中有效。同样存在暂时性死区 对于复合类型，const指向的是数据所在的地址，只是保证该地址不变，数据可以改变。Object.freeze可以将对象冻结。 解构赋值var [a,b,c] = [1,2,3]——属于模式匹配的写法。 可以从数组中提取值，按照对应位置，对变量赋值。 只要两边的模式相同，左边的变量就会赋予对应的值。 不想要的值可以用,隔开，如var [, , third] = [1,2,3];third//3 把多余的变量赋值成为数组：let [a,..b] = [1,2,3,4];a//1;b//[2,3,4]注意：...只能用在最末尾，不能用在中间。 解构不成功：变量等于undefined 默认值在左端定义默认值 1234567var [foo=true] = []foo//true[x,y=&#x27;b&#x27;] = [&#x27;a&#x27;]x//ay//b 对象的解构赋值变量必须与属性同名才能取到正确的值。 先找到同名属性，再赋值给变量 模式不会被赋值 对象的解构也可以使用默认值 字符串的解构赋值const [a,b,c,d,e] = &#39;hello&#39; 还可以对length解构赋值let &#123;length :len&#125; = &#39;hello&#39;;len//5 对象右边的值不是对象的话，则先转为对象。 函数参数的解构赋值建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号： 变量声明中不能使用圆括号 函数参数中不能使用圆括号 赋值语句中不能将整个模式或嵌套模式中的一层放入圆括号 可以使用圆括号——赋值语句中的非模式部分解构变量的用途 交换变量的值 [x,y] = [y,x] 从函数返回多个值 1234567891011121314function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); 函数参数的定义 提取JSON的数据 函数参数的默认值 遍历map结构 输入模块的指定方法 字符串的扩展加强对Unicode的支持：只要将码点放入{}。就能正确解读Unicode codePointAt() 返回一个字符的码点（十进制） string.fromCodePoint() 从码点返回字符 遍历器接口使字符串可以被for...of循环遍历 方法at()返回字符串的字节 ‘hello‘.at(0) //h repeat（）返回一个将源字符串重复n次的新字符串&#39;hello&#39;.repeat(n),参数不能是负数和Infinity。参数是0到1之间的小数：等同于0。NaN等同于0。参数是字符串：则先转为数字。 补全长度： padStart(),padEnd().长度之和若超过指定的最小长度：截去超出位数的补全字符串。省略第二个参数：用空格代替。 12345&#x27;x&#x27;.padStart(5, &#x27;ab&#x27;) // &#x27;ababx&#x27;&#x27;x&#x27;.padStart(4, &#x27;ab&#x27;) // &#x27;abax&#x27;&#x27;x&#x27;.padEnd(5, &#x27;ab&#x27;) // &#x27;xabab&#x27;&#x27;x&#x27;.padEnd(4, &#x27;ab&#x27;) // &#x27;xaba&#x27; 模板字符串用反引号标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 所有的空格和缩进都会被保留在输出之中。 模板字符串中嵌入变量，需要将变量名写在$&#123;&#125;之中。 正则的扩展如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/ig, &#x27;i&#x27;).flags// &quot;i&quot; 正则方法match(),replace(),search(),split() u修饰符 点字符 对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符。 1234var s = &#x27;𠮷&#x27;;/^.$/.test(s) // false/^.$/u.test(s) // true 上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。 ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。 123/\\u&#123;61&#125;/.test(&#x27;a&#x27;) // false/\\u&#123;61&#125;/u.test(&#x27;a&#x27;) // true/\\u&#123;20BB7&#125;/u.test(&#x27;𠮷&#x27;) // true 上面代码表示，如果不加u修饰符，正则表达式无法识别\\u&#123;61&#125;这种表示法，只会认为这匹配61个连续的u。 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。 1234/a&#123;2&#125;/.test(&#x27;aa&#x27;) // true/a&#123;2&#125;/u.test(&#x27;aa&#x27;) // true/𠮷&#123;2&#125;/.test(&#x27;𠮷𠮷&#x27;) // false/𠮷&#123;2&#125;/u.test(&#x27;𠮷𠮷&#x27;) // true 另外，只有在使用u修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。 u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。 12/^\\S$/.test(&#x27;𠮷&#x27;) // false/^\\S$/u.test(&#x27;𠮷&#x27;) // true 上面代码的\\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。 y修饰符y修饰符，叫做“粘连”（sticky）修饰符。 y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 属性sticky属性：是否设置了y修饰符 flags属性：返回正则表达式的修饰符 数值的扩展二进制：0b(0B) 八进制：0o(0O) 转为十进制：使用Number() Number.isFinite()用来检查一个数值是否为有限的（finite）。 Number.isNaN()用来检查一个值是否为NaN。 Number.parseInt(&#39;12.34&#39;) // 12 Number.parseFloat(&#39;123.45#&#39;) // 123.45 Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。 Number.EPSILON设置误差范围 Number.isSafeInteger()则是用来判断一个整数是否落在整数范围之内（整数范围在-2^53到2^53之间）。 Math对象的扩展Math.trunc() 去除小数部分，返回整数部分。对于非数值，则先转为数值。对于空值和无法截去小数的值：返回NaN。 Math.sign() 判断一个数是正数、负数还是零。 正数返回+1 负数返回-1 参数为0，返回0 参数为-0，返回-0 其他值：返回NaN Math.cbrt()计算一个数的立方根。对于非数值，则先转为数值。 Math.clz32() 返回一个数的32位无符号整数形式有多少个前导0。对于小数，只考虑整数部分。 Math.imul() 返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。 Math.fround方法返回一个数的单精度浮点数形式。 Math.hypot方法返回所有参数的平方和的平方根。 Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。 Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。 Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。 三角函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 数组的扩展 Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 Array.of方法用于将一组值，转换为数组。 数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 上面代码找出数组中第一个小于0的成员。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 fill方法使用给定值，填充一个数组。数组中已有的元素，会被全部抹去。 entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象 1234567891011121314151617for (let index of [&#x27;a&#x27;, &#x27;b&#x27;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&#x27;a&#x27;, &#x27;b&#x27;].values()) &#123; console.log(elem);&#125;// &#x27;a&#x27;// &#x27;b&#x27;for (let [index, elem] of [&#x27;a&#x27;, &#x27;b&#x27;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值 空位 空位 Array(3) // [, , ,]ES6则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 扩展运算符（...）也会将空位转为undefined。 copyWithin()会连空位一起拷贝。 fill()会将空位视为正常的数组位置。 for...of循环也会遍历空位。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 由于空位的处理规则非常不统一，所以建议避免出现空位。 函数的扩展允许为函数的参数设定默认值，即直接写在函数参数的后面。 1234567function log(x, y = &#x27;World&#x27;) &#123; console.log(x, y);&#125;log(&#x27;Hello&#x27;) // Hello Worldlog(&#x27;Hello&#x27;, &#x27;China&#x27;) // Hello Chinalog(&#x27;Hello&#x27;, &#x27;&#x27;) // Hello 参数变量是默认声明的，所以不能用let或const再次声明。 参数默认值可以与解构赋值的默认值，结合起来使用。 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5foo(&#123;x: 1&#125;) // 1, 5foo(&#123;x: 1, y: 2&#125;) // 1, 2foo() // TypeError: Cannot read property &#x27;x&#x27; of undefined rest参数（…val）：获取函数的多余参数.使用rest参数，可以向函数传入任意数目的参数。 扩展运算符（…）将一个数组转为用逗号分隔的参数序列 取代apply方法： Math.max(...[14,3,7]) 等同于Math.max(14,3,7) 通过push函数，将数组添加到另一个数组的尾部。 扩展运算符的应用： 合并数组 [...arr1, ...arr2, ...arr3] 与解构赋值结合[a, ...rest] = list 函数的多个返回值 将字符串转为真正的数组 [...&#39;hello&#39;] 实现Iterator接口对象.任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。 Map和Set结构，Generator函数 name箭头函数1var f = v =&gt; v; 上面的箭头函数等同于： 123var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 1var getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); 箭头函数与变量解构结合使用。 简化回调函数 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 数组排序： 1234567// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 箭头函数绑定this123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 尾调用概念：某个函数的最后一步是调用另一个函数。 不一定出现在函数尾部，只要最后一步操作是调用即可。 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 优化： 函数调用会形成调用记录——调用帧。所有的调用帧形成一个调用栈。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 尾递归尾调用自身，就成为尾递归 尾递归优化过的fibonacci 递归算法 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。 蹦床函数（trampoline）可以将递归执行转为循环执行。 123456function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125; 将原来的递归函数，改写为每一步返回另一个函数。 1234567function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125; 上面代码中，sum函数的每次执行，都会返回自身的另一个版本。 现在，使用蹦床函数执行sum，就不会发生调用栈溢出。 12trampoline(sum(1, 100000))// 100001 对象的扩展允许直接写入变量和函数，作为对象的属性和方法。 1234567891011121314151617181920var foo = &#x27;bar&#x27;;var baz = &#123;foo&#125;;baz // &#123;foo: &quot;bar&quot;&#125;// 等同于var baz = &#123;foo: foo&#125;;var birth = &#x27;2000/01/01&#x27;;var Person = &#123; name: &#x27;张三&#x27;, //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log(&#x27;我的名字是&#x27;, this.name); &#125;&#125;; 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。 1234567891011121314var cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels; &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error(&#x27;数值太小了！&#x27;); &#125; this._wheels = value; &#125;&#125; 如果某个方法的值是一个Generator函数，前面需要加上星号。 12345var obj = &#123; * m()&#123; yield &#x27;hello world&#x27;; &#125;&#125;; Object.is() 比较两个值是否严格相等 1234Object.is(&#x27;foo&#x27;, &#x27;foo&#x27;)// trueObject.is(&#123;&#125;, &#123;&#125;)// false Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象 实行的是浅拷贝，而不是深拷贝。 常见用途： 为对象添加属性 为对象添加方法 克隆对象 合并多个对象 为属性指定默认值 ES6一共有5种方法可以遍历对象的属性。 （1）for…in for...in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。 以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。 方法 __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf() __proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。 Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。 Object.getPrototypeOf与setPrototypeOf方法配套，用于读取一个对象的prototype对象。 Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的。Object.values不会返回这个属性。 Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。 Symbolsymbol 表示独一无二的值。 let s = Symbol() Symbol()函数前不能使用new。因为生成的Symbol是一个原始类型的值，不是对象。因此Symbol值也不能添加属性。 Symbol不能与其他类型的值进行运算，会报错。但是可以显式转为字符串。也可以转换为布尔值，但是不能转化为数值。 由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 Symbol值作为对象属性名时，不能用点运算符。 Symbol还可以用于定义一组常量，保证这组常量的值都是不相等的。 常用的消除魔术字符串的方法，就是把它写成一个变量。 123456789101112131415var shapeType = &#123; triangle: &#x27;Triangle&#x27;&#125;;function getArea(shape, options) &#123; var area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); 上面代码中，我们把“Triangle”写成shapeType对象的triangle属性，这样就消除了强耦合。 改用Symbol值。 123const shapeType = &#123; triangle: Symbol()&#125;; 上面代码中，除了将shapeType.triangle的值设为一个Symbol，其他地方都不用修改。 Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 Symbol.for方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。 Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 内置的Symbol值对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。 对象的Symbol.species属性，指向一个方法。该对象作为构造函数创造实例时，会调用这个方法。即如果this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的实例对象。 对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。 对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。 对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。 对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。 对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。 Set和Map数据结构Set：类似于数组，但是每个值都是唯一的。 123456var s = new Set();//初始化：var s1 = new Set([1,2,3,3,5]);[2,2,3,4,5,5,6].map(x =&gt;s.add(x));s//[2,3,4,5,6] Set的属性 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 操作方法：（操作数据） add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 Array.from方法可以将Set结构转为数组。 去除数组重复成员： 12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历方法： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员，没有返回值 需要特别指出的是，Set的遍历顺序就是插入顺序。 应用： 扩展运算符和Set结构相结合，就可以去除数组的重复成员。 123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 实现并集（Union）、交集（Intersect）和差集（Difference）。 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; weakSetWeakSet的成员只能是对象，而不能是其他类型的值。 WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。 WeakSet结构有以下三个方法。 **WeakSet.prototype.add(value)**：向WeakSet实例添加一个新成员。 **WeakSet.prototype.delete(value)**：清除WeakSet实例的指定成员。 **WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在WeakSet实例之中。 MapMap数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。 Map的属性 size 返回Map结构的成员总数 set(key,value) set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。 可以采用链式写法 get(key) get方法读取key对应的键值，如果找不到key，返回undefined。 has(key) has方法返回一个布尔值，表示某个键是否在Map数据结构中。 delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。 clear()clear方法清除所有成员，没有返回值。 Map 的方法遍历方法： keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历Map的所有成员。 （1）Map转为数组 前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。 123let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#x27;abc&#x27;]);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ] （2）数组转为Map 将数组转入Map构造函数，就可以转为Map。 12new Map([[true, 7], [&#123;foo: 3&#125;, [&#x27;abc&#x27;]]])// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125; （3）Map转为对象 如果所有Map的键都是字符串，它可以转为对象。 1234567891011function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;let myMap = new Map().set(&#x27;yes&#x27;, true).set(&#x27;no&#x27;, false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; （4）对象转为Map 12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// [ [ &#x27;yes&#x27;, true ], [ &#x27;no&#x27;, false ] ] （5）Map转为JSON Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。 1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set(&#x27;yes&#x27;, true).set(&#x27;no&#x27;, false);strMapToJson(myMap)// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27; 另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。 1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#x27;abc&#x27;]);mapToArrayJson(myMap)// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27; （6）JSON转为Map JSON转为Map，正常情况下，所有键名都是字符串。 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;)// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125; 但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。 123456function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap(&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;)// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125; Proxy和ReflectProxy用于修改某些操作的默认行为。属于一种元编程，即对编程语言进行编程。 Reflect Iterator和for…of循环Iterator 遍历器，为各种不同的数据结构提供统一的访问机制。 模拟next方法返回值的例子。 12345678910111213141516var it = makeIterator([&#x27;a&#x27;, &#x27;b&#x27;]);it.next() // &#123; value: &quot;a&quot;, done: false &#125;it.next() // &#123; value: &quot;b&quot;, done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。 1234567let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: &#x27;a&#x27;, done: false &#125;iter.next() // &#123; value: &#x27;b&#x27;, done: false &#125;iter.next() // &#123; value: &#x27;c&#x27;, done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 调用Iterator接口的场合： 解构赋值 扩展运算符 yield* 关于数组遍历的场合 for…offor…of 和for…in 的区别 12345678910let arr = [3, 5, 7];arr.foo = &#x27;hello&#x27;;for (let i in arr) &#123; console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;&#125;for (let i of arr) &#123; console.log(i); // &quot;3&quot;, &quot;5&quot;, &quot;7&quot;&#125; Generator函数Generator函数——异步编程解决方案。返回一个遍历器对象。 yield语句yield语句是暂停的标志。 遍历器对象的next方法的运行逻辑如下。 （1）遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。 （3）如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 Promise对象promise是一种异步编程的解决方案。 promise保存着某个未来才会结束的事件（通常是异步操作）。 promise是一个对象，可以获得异步操作的信息。 特点： 对象的状态不受外界影响。 promise的三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。状态只有异步操作的结果才能决定。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。 缺点： 无法取消promise 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法promise实例 123456789var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 可以用then方法分别指定Resolved状态和Reject状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); Promise对象的简单例子。 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, &#x27;done&#x27;); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); promise.prototype.then() 为Promise实例添加状态改变时的回调函数 Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 Promise.resolve方法将现有对象转为Promise对象 Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Diary","slug":"Diary","permalink":"http://example.com/tags/Diary/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}],"author":"YukiXueyan"},{"title":"我的前端学习路线","slug":"我的前端学习路线","date":"2021-03-14T01:43:55.000Z","updated":"2021-03-15T12:57:59.444Z","comments":true,"path":"2021/03/14/我的前端学习路线/","link":"","permalink":"http://example.com/2021/03/14/%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"现在还是处于一边准备春招一边复习的阶段，随时补充中…… JavaScript：现代JavaScript教程,从头开始过一遍，然后是《JavaScript高级教程》，争取每一部分都看懂，不懂的地方去掘金、微信公众号看别人发的帖子。还有《你不知道的JavaScript》、《JavaScript忍者秘籍》","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":"YukiXueyan"},{"title":"JavaScript 实用代码","slug":"JavaScript 实用代码","date":"2021-03-12T07:45:00.000Z","updated":"2021-03-15T12:56:44.898Z","comments":true,"path":"2021/03/12/JavaScript 实用代码/","link":"","permalink":"http://example.com/2021/03/12/JavaScript%20%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81/","excerpt":"","text":"JavaScript 实用代码 删除所有短横线，并将短横线后的每一个单词的首字母变为大写 camelize(&quot;background-color&quot;) == &#39;backgroundColor&#39;; 1234567891011121314function camelize(str) &#123; return str .split(&#x27;-&#x27;) // splits &#x27;my-long-word&#x27; into array [&#x27;my&#x27;, &#x27;long&#x27;, &#x27;word&#x27;] .map( // capitalizes first letters of all array items except the first one // converts [&#x27;my&#x27;, &#x27;long&#x27;, &#x27;word&#x27;] into [&#x27;my&#x27;, &#x27;Long&#x27;, &#x27;Word&#x27;] (word, index) =&gt; index == 0 ? word : word[0].toUpperCase() + word.slice(1) ) .join(&#x27;&#x27;); // joins [&#x27;my&#x27;, &#x27;Long&#x27;, &#x27;Word&#x27;] into &#x27;myLongWord&#x27;&#125;//缩减版：function x(str)&#123; return str.split(&#x27;-&#x27;).map((word,index)=&gt;index==0?word:word[0].toUpperCase()+word.slice(1)).join(&quot;&quot;)&#125; 写一个函数 filterRange(arr, a, b)，该函数获取一个数组 arr，在其中查找数值大于或等于 a，且小于或等于 b 的元素，并将结果以数组的形式返回一个新数组。 1234function filterRange(arr, a, b) &#123; // 在表达式周围添加了括号，以提高可读性 return arr.filter(item =&gt; (a &lt;= item &amp;&amp; item &lt;= b));&#125; 获取一个数组 arr，并删除其中介于 a 和 b 区间以外的所有值。检查：a ≤ arr[i] ≤ b。 12345678910111213function filterRangeInPlace(arr, a, b) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; let val = arr[i]; // 如果超出范围，则删除 if (val &lt; a || val &gt; b) &#123; arr.splice(i, 1); i--; &#125; &#125;&#125; /","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}],"author":"YukiXueyan"},{"title":"leetcode刷题记录","slug":"leetcode刷题记录","date":"2021-02-20T04:39:36.000Z","updated":"2021-02-20T10:24:40.757Z","comments":true,"path":"2021/02/20/leetcode刷题记录/","link":"","permalink":"http://example.com/2021/02/20/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"3. 无重复字符的最长子串3. 无重复字符的最长子串 思路： 滑动窗口方法，构造出散列表 123456789101112131415161718var lengthOfLongestSubstring = function(s) &#123; /*构造*/ const occ = new Set(); const n = s.length; let rk = -1,ans = 0;/*右指针*/ for(let i=0;i&lt;n;++i)&#123; if(i!=0)&#123; occ.delete(s.charAt(i-1)); &#125; while (rk + 1 &lt; n &amp;&amp; !occ.has(s.charAt(rk + 1))) &#123; occ.add(s.charAt(rk+1)); ++rk; &#125; ans = Math.max(ans, rk - i + 1); &#125; return ans;&#125;; 4. 寻找两个正序数组的中位数4. 寻找两个正序数组的中位数 思路： 调用concat()函数将两个数组合并 将数组排序(不用数组自带的arr.sort()方法是因为该方法无法正确判断当数组有负数的情况，所以需要另外写一个排序函数) 根据数组长度的奇偶求中位数（注意，当长度n为偶数时，中位数为数组的第n/2位和第n/2-1位，因为数组开头是0） 123456789101112131415161718192021222324252627282930/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */function sort(nums)&#123; for(let i=0;i&lt;nums.length-1;i++)&#123; for(let j=0;j&lt;nums.length-1-i;j++)&#123; if(nums[j]&gt;nums[j+1])&#123; let temp = nums[j+1]; nums[j+1] = nums[j]; nums[j] = temp; &#125; &#125; &#125; return nums; &#125;var findMedianSortedArrays = function(nums1, nums2) &#123; var num3 = nums1.concat(nums2); num3 = sort(num3); var ansNum = num3.length; if(ansNum%2 != 0)&#123; return num3[Math.floor(ansNum/2)]; &#125;else&#123; var ans = num3[ansNum/2]+num3[ansNum/2-1]; return ans/2; &#125; return null;&#125;; 56.合并区间12345678910111213141516class Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # 如果列表为空，或者当前区间与上一区间不重合，直接添加 if not merged or merged[-1][1] &lt; interval[0]: merged.append(interval) else: # 否则的话，我们就可以与上一区间进行合并 merged[-1][1] = max(merged[-1][1], interval[1]) return merged 94. 二叉树的中序遍历94. 二叉树的中序遍历 123456789101112131415var inorderTraversal = function(root) &#123; const res = []; const inorder = (root) =&gt; &#123; if (!root) &#123; return; &#125; inorder(root.left); res.push(root.val); inorder(root.right); &#125; inorder(root); return res;&#125;; 102. 二叉树的层序遍历102.二叉树的层序遍历 12345678910111213141516171819202122var levelOrder = function(root)&#123; const ret = []; if(!root)&#123; return ret; &#125; const q = []; q.push(root); while(q.length !== 0)&#123; const currentLevelSize =q.length; ret.push([]); for(let i = 1;i&lt;=currentLevelSize;i++)&#123; const node = q.shift(); ret[ret.length-1].push(node.val); if(node.left) q.push(node.left); if(node.right) q.push(node.right); &#125; &#125; return ret;&#125; 寻找6174 给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到 一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。 例如，我们从6767开始，将得到 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 7641 - 1467 = 6174 … … 现给定任意4位正整数，请编写程序演示到达黑洞的过程。 123456789101112131415161718function findNum(num) &#123; var str = &#x27;&#x27;; var node = &#x27;-&gt;&#x27;; var chazhi = num; str = str+chazhi.toString(); while(chazhi!=6174)&#123; var temp = (chazhi+&#x27;&#x27;).split(&quot;&quot;); var small = parseInt(temp.sort().join(&quot;&quot;)); var big = parseInt(temp.reverse().join(&quot;&quot;)); chazhi = big-small; str = str+node+chazhi.toString(); &#125; return str;&#125;console.log(findNum(2021));","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}],"author":"YukiXueyan"},{"title":"css揭秘读书笔记","slug":"css揭秘","date":"2021-02-18T07:23:00.000Z","updated":"2021-02-20T11:18:35.874Z","comments":true,"path":"2021/02/18/css揭秘/","link":"","permalink":"http://example.com/2021/02/18/css%E6%8F%AD%E7%A7%98/","excerpt":"","text":"CSS揭秘 编码技巧用到的工具函数$$() 12345function $$(selector,context)&#123; context = context||document; var elements = context.querySelectorAll(selector); return Array.prototype.slice.call(elements);&#125; w3c官网 层叠与继承 尽量减少代码重复 使用em单位，只在一处修改就可以改变所有元素的大小。 继承 inherit：绑定父元素的值color:inherit 在较大分辨率下得到固定长度时，使用max-width代替width. 使用多列文本时，指定column-width代替column-count（列数） 背景与边框半透明边框背景与边框 1234用内边距的外沿把背景裁切掉 border:10px solid hsla(0,0%,100%,5); background:red;background-clip: padding-box; 多重边框box-shadow可以不断叠加 1234background:yellowgreen;box-shadow: 0 0 0 10px #655,0 0 0 15px deeppink,0 2px 5px 15px rgba(0,0,0,.6); 使用outline 123background:yellowgreen;border: 10px solid #655;outline:5px solid deeppink; (! outline不会贴合元素的圆角) 灵活的背景定位背景偏移：设定偏移的位置和量 如下代码：与右边保持20px偏移量，与下边保持20px偏移量 1background-position:right 20px bottom 20px; 一般情况下，background-position以padding-box为准 用background-origin:content-box也能实现。 或者使用calc() : background-position:calc(100%-20px) calc(100%-20px) 从左上角偏移的角度考虑：有100%-20px的水平偏移量，100%-20px的垂直偏移量 边框内圆角容器外围有一道边框，只在内侧有圆角 1234567891011121314151617 &lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt; yuki &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .a&#123; background: #655; padding:.8em; &#125; .a &gt; div&#123; background:tan; border-radius: .8em; padding:1em; &#125;&lt;/style&gt; or 12345678910111213&lt;div class=&quot;a&quot;&gt; yuki&lt;/div&gt;&lt;style&gt; .a&#123; background:tan; border-radius: .8em; padding:1em; box-shadow: 0 0 0 .6em #655; outline: .6em solid #655; &#125;&lt;/style&gt; 通过勾股定理，计算圆角、阴影和边框的值 条纹背景水平条纹线性渐变background:linear-gradient(#fb3,#58a); 没有渐变的实色background:linear-gradient(#fb3 50%,#58a 50%); 重复，则可得到条纹背景 12background:linear-gradient(#fb3 33.3%,#58a 0,#58a 66.6% ,yellowgreen 0);background-size: 100% 45px; 垂直条纹12345.a&#123;background:linear-gradient(to right,#fb3 33.3%,#58a 0,#58a 66.6% ,yellowgreen 0);background-size:30px 100% ;padding: 200px;&#125; 斜向条纹1background:repeating-linear-gradient(30deg,#fb3,#fb3 15px, #58a 0,#58a 30px); 复杂的背景图案方格纹123background:white;background-image: linear-gradient(90deg,rgba(200,0,0,0.5) 50%,transparent 0),linear-gradient(rgba(200,0,0,0.5) 50%,transparent 0);background-size: 30px 30px; 波点123456.a&#123; background:#655; background-image: radial-gradient(tan 30%,transparent 0); background-size: 30px 30px;&#125; 12345678.a&#123; background:#655; background-image: radial-gradient(tan 30%,transparent 0), radial-gradient(tan 30%,transparent 0); background-size: 30px 30px;/*宽高*/ background-position: 0 0,15px 15px; /*背景偏移必须是宽高的一半*/&#125; 棋盘 三角形 1234567.a&#123; background:#eee; background-image: linear-gradient(45deg,#bbb 25%,transparent 0); background-size: 30px 30px; &#125; 棋盘 123456789101112.a&#123; padding: 200px; background:#eee; background-image: linear-gradient(45deg,#bbb 25%,transparent 0), linear-gradient(45deg,transparent 75%,#bbb 0), linear-gradient(45deg,#bbb 25%,transparent 0), linear-gradient(45deg,transparent 75%,#bbb 0); background-position: 0 0, 15px 15px,15px 15px,30px 30px; background-size: 30px 30px; &#125; 伪随机边框123456.a&#123; padding: 200px; background: hsl(20,40%,90%); background-image: linear-gradient(90deg,#fb3 11px,transparent 0),linear-gradient(90deg,#ab4 23px,transparent 0),linear-gradient(90deg,#655 41px,transparent 0); background-size: 80px 100%,60px 100%,40px 100%;&#125; 蝉原则： 使用质数增加随机性 《蝉原则在网页设计中的重要性》 形状自适应的椭圆圆形 123456.a&#123; background: #fb3; width: 200px; height: 200px; border-radius: 100px;/*正方形边长的一半*/&#125; 椭圆 123456.a&#123; background: #fb3; width: 400px; height: 200px; border-radius:50% / 50%;/*长宽的一半*/&#125; 半椭圆 12345border-radius:50% / 100% 100% 0 0 ;border-radius: 100% 0 0 100%/50%;border-radius: 100% 0 0 0; 平行四边形使用skew()的变形属性来对矩形进行斜向拉伸。transform:skewX(-45deg).为防止内容的斜向变形，还要在元素内部反向变形。 123456789101112.a&#123; position: relative; width: 100px;&#125;.a::before&#123; content:&#x27;&#x27;; position: absolute; top: 0;right: 0;bottom: 0;left: 0; z-index: -1; background: #58a; transform: skew(45deg);&#125; 菱形图片123456789.picture&#123; width:400px; transform:rotate(45deg); overflow:hidden;&#125;.picture &gt; img&#123; max-width: 100%; transform:rotate(-45deg) scale(1.42);&#125; or 1234567img&#123; clip-path: polygon(50% 0, 100% 50%,50% 100%,0 50%); transition: 1s clip-path;&#125;img:hover&#123; clip-path: polygon(0 0 ,100% 0, 100% 100%,0 100%);&#125; 切角效果四边切角 12345678910.a&#123; background:#58a; background: linear-gradient(135deg,transparent 15px,#58a 0)top left, linear-gradient(-135deg,transparent 15px,#58a 0)top right, linear-gradient(-45deg,transparent 15px,#58a 0)bottom right, linear-gradient(45deg,transparent 15px,#58a 0)bottom left; background-size: 50% 50%; background-repeat: no-repeat;&#125; 两边切角 123456789.a&#123; padding:100px; background:#58a; background: linear-gradient(-45deg,transparent 15px,#58a 0)bottom right, linear-gradient(45deg,transparent 15px,#58a 0)bottom left; background-size: 50% 100%; background-repeat: no-repeat;&#125; 弧形切角 123456789101112.a&#123; padding:100px; background:#58a; background: radial-gradient(circle at top left,transparent 15px,#58a 0)top left, radial-gradient(circle at top right,transparent 15px,#58a 0)top right, radial-gradient(circle at bottom right,transparent 15px,#58a 0)bottom right, radial-gradient(circle at bottom left,transparent 15px,#58a 0)bottom left; background-size: 50% 50%; background-repeat: no-repeat;&#125; 梯形标签页1234567891011121314151617181920212223nav &gt; a&#123; position: relative; display: inline-block; padding: .3em 1em 0;&#125;nav &gt; a::before&#123; content:&#x27;&#x27;; position: absolute; top: 0;right: 0;bottom: 0;left: 0; z-index:-1; background: #ccc; background-image: linear-gradient( hsla(0,0%,100%,.6), hsla(0,0%,100%,0) ); border: 1px solid rgba(0,0,0,.4); border-bottom: none; border-radius: .5em .5em 0 0; box-shadow: 0 .15em white inset; transform: perspective(.5em) rotateX(5deg); transform-origin:bottom;&#125; 视觉效果单侧投影 单侧投影 box-shadow: 水平偏移量，垂直偏移量，投影长度，扩张半径，颜色;当扩张半径为负的投影长度时，则可达到隐藏效果，只显示其中一条投影 只有底边有投影： box-shadow: 0 5px 4px -4px Black; 只有右边有投影box-shadow: 5px 0 4px -4px Black; 邻边投影 box-shadow: 水平偏移量，垂直偏移量，投影长度，扩张半径，投影颜色;水平偏移量和垂直偏移量要大于模糊半径的一半 box-shadow: 5px 5px 8px -4px Black; 双侧投影 投影设置在对边 将单侧投影设置两次 box-shadow: 5px 0 5px -5px Black,-5px 0 5px -5px Black; 不规则投影滤镜效果规范 染色效果1234567img&#123; transition:.5s filter; filter:sepia(1) saturate(4) hue-rotate(295deg);&#125;img:hover,img:focus&#123; filter: none;&#125; or 1234567a&#123;/*使用超链接包裹图片*/ background:hsl(335, 100%,50%)&#125;img&#123; mix-blend-mode: luminosity;&#125; 毛玻璃效果123456789101112131415body,main::before&#123; background:url(&quot;fw.png&quot;) 0 / cover fixed;&#125;main&#123; position:relative; background: hsla(0, 0%, 100%, .3); overflow:hidden;&#125;main::before&#123; content: &#x27;&#x27;; position: absolute; top:0;right: 0;bottom:0;left:0; filter: blur(20px); margin: -30px;&#125; 折角效果1234567.a&#123; padding: 200px; background:#58a; background: linear-gradient(to left bottom,transparent 50%,rgba(0,0,0,.4) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg,transparent 1.5em,#58a 0);&#125; 字体排印连字符断行插入换行文本行的斑马条纹调整tab的宽度连字华丽的&amp;符号自定义下划线现实中的文字效果环形文字用户体验选用合适的鼠标光标扩大可点击区域自定义复选框通过阴影柔化背景通过模糊弱化背景滚动提示交互式图片对比控件结构与布局自定义内部元素精确控制表格列宽根据兄弟元素的数量设置样式满幅的背景，定宽的内容垂直居中紧贴底部的页脚过渡与动画缓动效果逐帧动画闪烁效果打字动画状态平滑的动画沿环形路径平移的动画","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"author":"YukiXueyan"},{"title":"JavaScript忍者秘籍","slug":"JavaScript忍者秘籍","date":"2021-02-17T08:19:17.000Z","updated":"2021-05-05T06:18:13.812Z","comments":true,"path":"2021/02/17/JavaScript忍者秘籍/","link":"","permalink":"http://example.com/2021/02/17/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D/","excerpt":"","text":"JavaScript忍者秘籍入门了解市场上的JavaScript库，如jQuery，prototype，base2 掌握跨浏览器开发。 掌握测试方法。 测试运用日志记录和断点进行调试。console.log() 函数 函数为什么如此重要 函数为什么是第一型对象 浏览器如何调用函数 函数声明 参数赋值之谜 函数上下文 第一型(first-class)对象 函数可以共处，可以被视为任意类型的JavaScript变量，被任意变量进行引用，或进行传递。 浏览器的事件轮询是单线程的，遵循FIFO顺序（先进先出）。 window.onload()调用函数 函数作用域函数调用 作为一个函数被调用 作为一个方法被调用，在对象上进行调用，支持面向对象编程 作为构造器进行调用 通过apply()或call()进行调用 参数声明 如果声明的参数数量大于实际传递的参数数量，则没有对应参数的形参会声明为undefined 如果声明的参数数量小于实际传递的参数数量，超出的参数则不会配给形参名称 隐式参数：argument，this 构造器挥舞函 数 匿名函数为什么如此重要 函数调用时的引用形式，包括递归 函数引用的存储 函数上下文的利用 处理可变长度的参数列表 判断一个对象是否是函数 匿名函数示例12345678910111213window.onload = function()&#123;console.log(&quot;hi&quot;);&#125;;var ninja = &#123; shout:function()&#123; console.log(&quot;hi&quot;); &#125;;&#125;;ninja.shout();setTimeout(function()&#123; console.log(&quot;hi&quot;);&#125;,500); 对象中的方法递归123456var ninja = &#123; chirp:function(n)&#123; return n &gt; 1?ninja.chirp(n-1)+&quot;-chirp&quot;:&quot;chirp&quot;; &#125;&#125;;assert(ninja.chirp(3) == &quot;chirp-chirp-chirp&quot;,&quot;。。。&quot;); 存储一组独立的函数闭包一个简单的闭包 1234567&lt;script type=&quot;text/javascript&quot;&gt; var outerValue = &#x27;ninja&#x27;; function outerFunction()&#123; console.assert(outerValue == &quot;ninja&quot;,&quot;i can see the ninja&quot;); &#125; outerFunction(); &lt;/script&gt; 一个不那么简单的闭包 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; var outerValue = &#x27;ninja&#x27;; var later; function outerFunction()&#123; var innerValue = &#x27;samurai&#x27;; function innerFunction()&#123; console.assert(outerValue,&quot;i can see ninja&quot;); console.assert(innerValue,&quot;i can see samurai&quot;); &#125; later = innerFunction; &#125; outerFunction(); later();&lt;/script&gt; 使用闭包模拟私有变量 12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt; function Ninja()&#123; var feints = 0; this.getFeints = function()&#123; return feints; &#125;; this.feint = function()&#123; feints++; &#125;; &#125; var ninja = new Ninja(); ninja.feint(); console.assert(ninja.getFeints()==1,&quot;internal feint count&quot;); console.assert(ninja.feints==undefined,&quot;data is inaccessible&quot;);&lt;/script&gt; 另一个使用闭包的最常见情形就是处理回调或使用定时器。 原型与面向对象 利用函数实现构造器 探索原型 利用原型实现对象的扩展 避免常见的问题 构建可继承的类 利用原型方法创建一个新实例12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; function Ninja()&#123;&#125;; Ninja.prototype.swingSword = function()&#123; return true; &#125;; //函数作为函数进行调用 var ninja1 = Ninja(); console.assert(ninja1 === underfined,&quot;no instance of ninja created&quot;) //函数作为构造器进行调用 var ninja2 = new Ninja(); console.assert(ninja2&amp;&amp;ninja2.swingSword&amp;&amp;ninja2.swingSword(),&quot;instance exists and method is callable&quot;);&lt;/script&gt; 继承与原型链通过prototype，让ninja拥有person的跳舞能力。但ninja不是一个Person 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; function Person()&#123; &#125;; Person.prototype.dance = function()&#123;&#125;; function Ninja()&#123;&#125;; Ninja.prototype = &#123;dance:Person.prototype.dance&#125;; var ninja = new Ninja(); console.log(ninja instanceof Ninja); console.log(ninja instanceof Person); console.log(ninja instanceof Object);&lt;/script&gt; 创建一个原型链SubClass.prototype = new SuperClass() Ninja.prototype = new Person() 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; function Person()&#123; &#125;; Person.prototype.dance = function()&#123;&#125;; function Ninja()&#123;&#125;; Ninja.prototype = new Person(); var ninja = new Ninja(); console.log(ninja instanceof Ninja); console.log(ninja instanceof Person); console.log(ninja instanceof Object);&lt;/script&gt; 通过HTMLElement的原型，给元素添加一个新方法 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; HTMLElement.prototype.remove = function()&#123; if (this.parentNode) this.parentNode.removeChild(this); &#125;; var a = document.getElementById(&quot;a&quot;); a.parentNode.removeChild(a); document.getElementById(&quot;b&quot;).remove(); console.log(!document.getElementById(&quot;a&quot;)); console.log(!document.getElementById(&quot;b&quot;));&lt;/script&gt; 陷阱给Object原型添加额外属性会发生的行为1234567891011&lt;script type=&quot;text/javascript&quot;&gt; Object.prototype.keys = function()&#123; var keys = []; for(var p in this) keys.push(p); return keys; &#125; var obj = &#123;a:1,b:2,c:3&#125;; console.log(obj.keys().length);//结果返回了4&lt;/script&gt; 使用hasOwnProperty进行修改 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; Object.prototype.keys = function()&#123; var keys = []; for(var p in this) if(this.hasOwnProperty(p)) keys.push(p); return keys; &#125; var obj = &#123;a:1,b:2,c:3&#125;; console.log(obj.keys().length);//结果返回了4&lt;/script&gt; 扩展数字123456789&lt;script type=&quot;text/javascript&quot;&gt; Number.prototype.add = function(num)&#123; return this+num; &#125; var n = 5; console.log(n.add(3)); console.log((5).add(3)); console.log(5.add(3));//报错，因为语法解析器不能处理字面量的情况&lt;/script&gt; 继承12345678910111213141516171819202122232425262728293031323334&lt;script type=&quot;text/javascript&quot;&gt; var Person =Object.subClass(&#123; init:function(isDancing)&#123; this.dancing = isDancing; &#125;, dance:function()&#123; return this.dancing; &#125; &#125;); var Ninja = Person.subClass(&#123; init:function()&#123; this._super(false); &#125;, dance:function()&#123; return this._super(); &#125;, swingSword:function()&#123; return true; &#125; &#125;); var person = new Person(true); console.log(person.dance()); var ninja = new Ninja(); console.log(ninja.dance()); console.log(ninja.swingSword()); console.log(person instanceof Person); console.log(ninja instanceof Ninja); console.log(ninja instanceof Person); &lt;/script&gt; 正则表达式驯服线程和定时器定时器定时器的操作方法 方法 格式 描述 setTimeout id = setTimeout(fn,delay) 启动一个定时器，在一段时间delay之后执行传入的callback，并返回该定时器的唯一标识 clearTimeout clearTimeout(id) 如果定时器还未触发，则可取消该定时器 setInterval id = setInterval(fn,delay) 启动一个定时器，在每隔一段时间delay之后都执行传入的callback，并返回该定时器的唯一标识 clearInterval clearInterval(id) 传入间隔定时器标识，取消间隔定时器 运行时代码求值 运行时代码求值如何工作的 代码求值的不同技术 在应用程序中代码求值 函数反编译 命名空间 压缩与混淆 求值方式包括 eval()函数 函数构造器 定时器 &lt;script&gt;元素 with语句开发跨浏览器策略洞悉特性、属性和样式不老事件DOM操作CSS选择器引擎","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}],"author":"YukiXueyan"},{"title":"JavaScriptDOM","slug":"JavaScriptDOM","date":"2021-02-11T05:06:39.000Z","updated":"2021-03-15T12:55:36.276Z","comments":true,"path":"2021/02/11/JavaScriptDOM/","link":"","permalink":"http://example.com/2021/02/11/JavaScriptDOM/","excerpt":"","text":"JavaScript导入 将JavaScript代码放到&lt;header&gt;标签中的&lt;script&gt;中 将JavaScript代码存进.js文件中，使用&lt;script src=&quot;&quot;&gt;导入。最好的方法是放到&lt;/body&gt;之前 javascript 语法 语句 多条语句放在不同得行上就可以分隔它们 多条语句放在同一行上：用分号分隔 建议在每条语句后都加入分号 注释 用// 注释单行，/**/注释多行 声明和赋值 var a=&quot;happy&quot;,x = 33 转义 使用反斜线\\进行转义 关联数组（不推荐使用） var lemon = Array();lemon[&quot;name&quot;] = &quot;John&quot; 拼接 字符串+数值 返回字符串；alert(&quot;10&quot;+20) //返回“1020” 数值+字符串 返回数值的算术和alert(10+“20”) //返回30 对象 有属性和方法 继承 实例 点击链接切换图片 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;1.jpg&quot; title=&quot;罗云熙&quot; onclick=&quot;showpic(this);return false;&quot;&gt;罗云熙&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;2.jpg&quot; title=&quot;王一博&quot;onclick=&quot;showpic(this);return false;&quot;&gt;王一博&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;3.jpg&quot; title=&quot;赵丽颖&quot;onclick=&quot;showpic(this);return false;&quot;&gt;赵丽颖&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img src=&quot;1.jpg&quot; id=&quot;placeholder&quot; alt=&quot;image&quot;&gt; &lt;script&gt; function showpic(whichpic)&#123; var source = whichpic.getAttribute(&quot;href&quot;); var placeholder = document.getElementById(&quot;placeholder&quot;); placeholder.setAttribute(&quot;src&quot;,source); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; window.open(url,name,features)创建新的浏览器窗口 features : 新窗口的属性，如尺寸、启动和禁用的功能等 DOM Core getElementById getElementByTagName getElementByClassName getAttribute setAttribute 动态创建标记 document.write createElement appendChild createTextNode nextSibling 查找下一个节点 setTimeout 让某个函数在经过一段时间后才开始执行 CSS中的overflow属性用来处理一个元素的尺寸超出其容器的情况。可取值如下： visible:不裁剪溢出的内容。浏览器吧溢出的内容呈现在其元素的显示区域以外，全部内容都可见。 hidden:隐藏溢出的内容。内容只显示在容器的显示区域里，只有以部分内容可见。 scroll:对溢出的内容进行隐藏，但显示一个滚动条以便让用户看到内容的其他部分。 auto:只有发生溢出时才显示滚动条。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}],"author":"YukiXueyan"},{"title":"CSSCode","slug":"CSSCode","date":"2021-02-10T09:11:52.000Z","updated":"2021-03-15T12:57:18.331Z","comments":true,"path":"2021/02/10/CSSCode/","link":"","permalink":"http://example.com/2021/02/10/CSSCode/","excerpt":"","text":"1 文字和字体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/*$1.1 自定义字体*/@font-face&#123; font-family: xujinglei;/*字体名称*/ src:url(xujinglei.ttf),url(xujinglei.eot);/*字体路径*/&#125;.font&#123; font-family: xujinglei;/*使用字体*/ font-size: 18px;&#125;/*$1.2 首字符下沉*/#a&#123; text-indent: 15px;&#125;#b&#123; text-indent: -6px;&#125;#c&#123; text-indent: 0.5em;&#125;#b::first-letter&#123; font-size: 30px; color:red;&#125;#c::first-letter&#123; font-size: 30px; color:#b23aee; float:left;/*下沉必须浮动*/&#125;p.uppercase::first-letter&#123; text-transform: uppercase;/*大写*/&#125;/*$1.3 文本被选中时的样式*/::selection&#123; background-color: silver; color:gold;&#125;::-moz-selection&#123; /*firefox设置*/ background-color: silver; color:gold;&#125;/*$1.4 文本对齐*/p.duiqi&#123; text-align: center;/*居中*/ /*text-align: left; 左对齐*/ /*text-align: right; 右对齐*/ line-height: 15px; /*行高设置*/&#125;/*$1.5 设置文字、字符的间距*/p.wordspacing&#123;word-spacing:20px;&#125;/*设置空格的长度*/p.letterspacing&#123;letter-spacing:20px;&#125;/*设置字间距*/p.lineheight&#123;line-height:O.3;&#125;/*设置行间距*/p.whitespace_normal&#123;white-space:normal;&#125;/*默认，忽略多个空格为1个，忽略回车符*/p.whitespace_pre&#123;white-space:pre;&#125;/*保留多个空格*/p.whitespace_nowrap&#123;white-space:nowrap;&#125;/*忽略回车符，禁止换行，直到遇到br*/p.whitespace_prewrap&#123;white-space:pre-wrap;&#125;/*保留所有空格符与回车符*/p.whitespace_preline&#123;white-space:pre-line;&#125;/*忽略多个空格为1个，保留回车*//*$1.6 文本的装饰——画线、粗体、斜体*/.overline&#123;text-decoration: overline;&#125;.through&#123;text-decoration: line-through;&#125;.underline&#123;text-decoration: underline;&#125;.bold&#123;font-weight: bold;&#125;.italic&#123;font-style:italic ;&#125;.oblique&#123;font-style:oblique ;&#125;/*$1.7 文字阴影*/.shadow&#123;text-shadow: 5px 5px 5px #6600ff;&#125;/*$1.8 毛玻璃效果*/.shadow-glass&#123; text-shadow: 1px 1px 2px 2px #ccc; color: rgba(0,0,0,0); text-shadow: 0 0 10px black;&#125;/*$1.9 文本溢出处理*//*常见的溢出处理方式： 简单裁切 简单隐藏 隐藏并显示省略号 使用滚动条*//*简单裁切*/.hide&#123; overflow: hidden;&#125;/*简单隐藏*/.scroll&#123; overflow: scroll;&#125;/*隐藏并显示省略号*/.clip&#123; border:1px solid; overflow: hidden; white-space: nowrap; text-overflow: clip;&#125;/*使用滚动条*/.elli&#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125;/*$1.10 金属质感文字*//*添加一个使用半透明和渐变效果的遮罩层*/p&#123; color:white; background: black; font-weight: bold; font-size: 30px; position: relative;&#125;span.cover&#123; width: 100%; height:100%; position: absolute; background: linear-gradient(to bottom,black 0%,transparent 50%,black); opacity: 0.5;/*设置透明度*/&#125; 2 边框和图片基础搜索框微博发布框拍立得效果框CSS3 动画边框边框移动特效Banner图片的标签黑白图片图片水印图片细节放大展示图片瀑布流幻灯片手风琴图片自适应纯CSS绘制图像图片原地放大图片翻转图像地图","categories":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":"YukiXueyan"},{"title":"精通CSS","slug":"精通css","date":"2021-02-08T08:19:29.000Z","updated":"2021-03-15T12:58:06.796Z","comments":true,"path":"2021/02/08/精通css/","link":"","permalink":"http://example.com/2021/02/08/%E7%B2%BE%E9%80%9Acss/","excerpt":"","text":"删除每个元素默认的浏览器内边距和外边距 1234*&#123; padding:0; margin:0;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"author":"YukiXueyan"},{"title":"CSS 选择器世界","slug":"CSS选择器世界","date":"2021-02-08T02:19:29.000Z","updated":"2021-02-18T07:19:30.863Z","comments":true,"path":"2021/02/08/CSS选择器世界/","link":"","permalink":"http://example.com/2021/02/08/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%96%E7%95%8C/","excerpt":"","text":"1 概述1.1为什么CSS选择器很强CSS为样式服务，重表现，轻逻辑。 1.2CSS选择器世界的一些基本概念1.2.1选择器、选择符、伪类和伪元素选择器： 是CSS语句块前的标签、类名等，如body&#123;font:menu&#125;中的body 选择符：后代选择符空格()，子选择符箭头(&gt;)，相邻兄弟选择符加号(+)，随后兄弟选择符弯弯(~)，列选择符双管道(||)。 （详见第4章） 伪类：与用户行为有关，前面有一个:的，如：hover 伪元素：前面有两个冒号的 1.2.2CSS选择器的作用域有局部作用域 Shadow DOM与局部作用域实例页面 12&lt;p&gt;我是一个普通的&amp;lt;p&amp;gt;元素，我的背景色是？&lt;/p&gt;&lt;div id=&quot;hostElement&quot;&gt;&lt;/div&gt; 123456// 创建 shadow DOMvar shadow = hostElement.attachShadow(&#123;mode: &#x27;open&#x27;&#125;);// 给 shadow DOM 添加文字shadow.innerHTML = &#x27;&lt;p&gt;我是由Shadow DOM创建的&amp;lt;p&amp;gt;元素，我的背景色是？&lt;/p&gt;&#x27;;// 添加CSS，文字背景色变成黑色shadow.innerHTML += &#x27;&lt;style&gt;p &#123; background-color: #333; color: #fff; &#125;&lt;/style&gt;&#x27;; 1.2.3 CSS选择器的命名空间命名空间：namespace 作用：避免冲突 （了解即可） 1.3无效CSS选择器特性与实际应用使用新的CSS选择器时，为了避免浏览器之间不同的支持程度，因此最好分开书写。 例外：浏览器可以识别以-webkit-私有前缀开头的伪元素 2 CSS选择器的优先级2.1CSS优先级规则概览级别越高，优先级越高： 0级：通配选择器(*)、选择符{+,&gt;,~,空格,||}、逻辑组合伪类:not(),:is(),:where 1级：标签选择器body&#123;&#125;,p&#123;&#125; 2级：类选择器.foo&#123;&#125; 属性选择器[foo]&#123;&#125;、伪类:hover&#123;&#125; 3级：id选择器#foo&#123;&#125; 4级：style属性内联&lt;div style=&quot;color:#000000&quot;&gt; 5级：！important顶级优先级 2.2深入CSS选择器优先级2.2.1 CSS选择器优先级的计算规则0级选择器：优先级数值+0；1级选择器：优先级数值+1；2级选择器：优先级数值+10；3级选择器：优先级数值+100； 优先级数值一样：遵循“后来居上”原则，后渲染的优先级高。这是相对于整个页面文档，所以css文件的引入顺序也很重要。 增加CSS优先级的技巧 重复选择器自身.foo.foo&#123;&#125; 借助必然会存在的属性选择器.foo[class]&#123;&#125; 2.2.2 256个选择器的越级现象256个标签选择器的优先级大于类名选择器，因为出现了溢出。 3 CSS选择器的命名3.1CSS选择器是否区分大小写 -选择器类型 -示例 -是否对大小写敏感 标签选择器 div{} 不敏感 属性选择器-纯属性 [attr] 不敏感 属性选择器 [attr=val] 属性值敏感 类选择器 .container{} 敏感 ID选择器 #foo{} 敏感 3.2CSS选择器命名的合法性 类名选择器和ID选择器不能以数字开头 .\\31-foo&#123;&#125; &lt;span class=&quot;1-foo&quot;&gt;string&lt;/span&gt; 以字符开头的选择器需要转义 支持中文字符和中文标点符号 支持emoji表情 3.3CSS选择器的命名是一个哲学问题3.3.1长命名还是短命名使用短命名 3.3.2单命名还是组合命名 使用前缀将常见的单词模块保护起来，避免冲突。 前缀最好是项目缩写。 一个项目的前缀最好统一。 3.3.3面向属性的命名和面向语义的命名小项目使用面向语义的命名方式，大项目采用面向属性的命名和面向语义的命名结合。 面向属性的命名： 12345678910.dn &#123; display: none;&#125;.db &#123; display: block;&#125; .df &#123; display:flex;&#125; .dg &#123; display: grid;&#125;.fl &#123; float:left;&#125;.fr &#123; float: right;&#125;.tl&#123; text-align: left; &#125; .tr &#123; text-align: right;&#125; .tc&#123; text-align: center; &#125; .tj&#123;text-align:justify;&#125; 面向语义的命名则是根据应用元素所处的上下文来命名的。 12 .header &#123; background-color: #333; color:#fff;&#125;.logo &#123; font-size: 0;color:transparent;&#125; 3.4CSS选择器设计的最佳实践3.4.1不要使用ID选择器缺陷： 优先级太高，不利于覆盖和修改 可以使用属性选择器[id=&quot;csId&quot;] 和JavaScript耦合,产生bug 3.4.2不要嵌套选择器会限制HTML的结构，不利于后期修改HTML，调整层级和位置。 错误示例： 12345.nav a &#123;&#125;.box &gt; div&#123;&#125; .avatar img &#123;&#125; .box .pic .icon &#123;&#125;.upbox .input .upbtn &#123;&#125; 正确用法：使用无嵌套的类名选择器 3.4.3不要歧视面向属性的命名3.4.4正确使用状态类名3.4.5最佳实践汇总 命名 命名最好使用小写，用-或_连接 不推荐驼峰命名，驼峰命名留给JavaScript DOM 组合个数控制在5个以下 设置统一前缀 选择器类型选择 推荐用属性选择器代替id选择器 4 CSS选择符4.1后代选择符空格( )4.1.1对CSS后代选择符可能错误的认识e.g 12345678910111213&lt;div class=&quot;lightblue&quot;&gt; &lt;div class=&quot;darkblue&quot;&gt; &lt;p&gt;1. 颜色是？&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;darkblue&quot;&gt; &lt;div class=&quot;lightblue&quot;&gt; &lt;p&gt;2. 颜色是？&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;.lightblue p &#123; color: lightblue; &#125;.darkblue p &#123; color: darkblue; &#125; 4.1.2对JavaScript中后代选择符可能错误的认识4.2子选择符箭头(&gt;)4.2.1子选择符和后代选择符的区别子选择符只会匹配第一代子元素，后代选择符会匹配所有的后代。 4.2.2适合使用子选择符的场景尽量不使用 子选择符会限制HTML的层级关系 使用场景： 状态类名控制 标签受限 层级位置判断 4.3相邻兄弟选择符加号(+)只能选择相邻的兄弟元素，且只是选择后面一个兄弟。 4.3.1相邻兄弟选择符的相关细节忽略文本节点 忽略注释 4.3.2实现类似:first-child的效果.cs-li + p&#123;color：#424242&#125; 所有p元素都带cs-li属性，则只有第一个&lt;p&gt;中的文字没有颜色设置。 4.3.3众多高级选择器技术的核心配合伪类实现交互效果，如 123456789用户名:&lt;input&gt;&lt;span class=&quot;cs-tips&quot;&gt;不超过10个字符&lt;/span&gt; .cs-tips&#123;color: gray;margin-left:15px;position: absolute;visibility: hidden;&#125;:focus + .cs-tips &#123;visibility: visible;&#125; 4.4随后兄弟选择符弯弯(~)4.4.1和相邻兄弟选择符区别随后兄弟选择符会匹配后面所有的兄弟元素。 4.4.2为什么没有前面兄弟选择符浏览器解析HTML是从前往后，从外往里进行。如果有前面兄弟选择符 ，网页呈现速度将大大减慢，浏览器会出现长时间的白板。 4.4.3如何实现前面兄弟选择符的效果设置位置，将后面兄弟的位置设置在前面兄弟的前面。 flex布局实现 123456789101112131415161718&lt;div class=&quot;cs-flex&quot;&gt; &lt;input class=&quot;cs-input&quot;&gt;&lt;label class=&quot;cs-label&quot;&gt;用户名&lt;/label&gt;&lt;/div&gt;.cs-flex&#123;display:inline-flex; flex-direction: row-reverse;&#125; .cs-input&#123; width:200px; &#125; .cs-label&#123; width:64px; &#125; :focus ~ .cs-label&#123; color:darkblue; text-shadow: 0 0 1px; &#125; float浮动实现 123456789101112131415161718&lt;div class=&quot;cs-float&quot;&gt; &lt;input class=&quot;cs-input&quot;&gt;&lt;label class=&quot;cs-label&quot;&gt;用户名&lt;/label&gt; &lt;/div&gt; .cs-float&#123; width:264px; &#125; .cs-input&#123; float:right; width:200px; &#125; .cs-label&#123; display: block; overflow:hidden; &#125; :focus ~ .cs-label&#123; color:darkblue; text-shadow: 0 0 1px; absolute绝对定位实现 1234567891011121314151617181920.cs-absolute&#123;width:264px; position:relative;&#125; .cs-input&#123; margin-left: 64px; width:200px; &#125; .cs-label&#123; position:absolute; left:0; &#125; :focus ~ .cs-label&#123; color:darkblue; text-shadow: 0 0 1px; &#125; &lt;div class=&quot;cs-absolute&quot;&gt; &lt;input class=&quot;cs-input&quot;&gt;&lt;label class=&quot;cs-label&quot;&gt;用户名&lt;/label&gt;&lt;/div&gt; direction属性实现 1234567891011121314151617.cs-direction&#123;direction: rtl;&#125; .cs-direction .cs-label,.cs-direction .cs-input&#123; direction: ltr; &#125; .cs-label&#123; display:inline-block; &#125; :focus ~ .cs-label&#123; color:darkblue; text-shadow: 0 0 1px; &#125;&lt;div class=&quot;cs-direction&quot;&gt; &lt;input class=&quot;cs-input&quot;&gt;&lt;label class=&quot;cs-label&quot;&gt;用户名&lt;/label&gt;&lt;/div&gt; 4.5快速了解列选择符双管道(||)5 元素选择器5.1元素选择器的级联语法元素选择器是唯一不能重复自身的选择器 级联使用时，元素选择器必须写在最前面。 5.2标签选择器二三事5.2.1标签选择器混合其他选择器的优化5.2.2标签选择器与自定义元素5.3特殊的标签选择器:通配选择器6 属性选择器6.1 ID选择器和类选择器 语法不同 优先级不同 唯一性与可重复性 类可以重复使用，但id选择器要使用需要写完所有的id 1234&lt;button id=&quot;cs-button cs-button-primary&quot;&gt;main&lt;/button&gt;#cs-button\\20cs-button-primary&#123;&#125;/*或者*/[id~=&quot;cs-button&quot;] 6.2属性值直接匹配选择器 [attr] [attr=”val”] [attr~=”val”] [attr|=”val”] 6.2.1详细了解4种选择器 [attr] 只要包含了指定的属性就匹配，不关心属性的值 [attr=”val”] 属性值需要完全匹配 不区分单双引号 引号可以省略 属性值包含空格，则需要转义或者老老实实使用引号 [attr~=”val”] 属性值单词完全匹配选择器 属性值单词完全匹配选择器非常适合包含多种组合属性值的场景，例如，某元素共有9种 定位控制: 123456789&lt;div data-align=&quot;left top&quot;&gt;&lt;/div&gt;&lt;div data-align=&quot;top&quot;&gt;&lt;/div&gt;&lt;div data-align=&quot;right top&quot;&gt;&lt;/div&gt;&lt;div data-align=&quot;right&quot;&gt;&lt;/div&gt;&lt;div data-align=&quot;right bottom&quot;&gt;&lt;/div&gt;&lt;div data-align=&quot;bottom&quot;&gt;&lt;/div&gt;&lt;div data-align=&quot;left bottom&quot;&gt;&lt;/div&gt;&lt;div data-align=&quot;left&quot;&gt;&lt;/div&gt;&lt;div data-align=&quot;center&quot;&gt;&lt;/div&gt; 此时，最佳实践就是使用属性值单词完全匹配选择器: 12345[data-align] &#123; left: 5Ot;top:508;&#125;[data-align~=&quot;top&quot;] &#123; top: O;&#125;[data-align~=&quot;right&quot;] &#123; right:0;&#125;[data-align~=&quot;bottom&quot;] &#123; bottom: O;&#125;[data-align~=&quot;left&quot;]&#123; left:0;&#125; [attr|=”val”] 属性值起止片段完全匹配选择器，属性的值要么是“val”,要么以”val”开头 6.2.2AMCSS开发模式简介6.3属性值正则匹配选择器 [attr^=”val”] 前匹配 [attr$=”val”] 后匹配 [attr*=”val”] 任意匹配 6.3.1详细了解3种选择器 [attr^=”val”] 表示匹配attr属性值以字符val开头的元素 可以匹配中文，如果没有空格，则引号可以省略 [attr$=”val”] 后匹配 表示匹配attr属性值以字符val结尾的元素 [attr*=”val”] 任意匹配 表示匹配attr属性值包含字符val的元素 6.3.2 CSS属性选择器搜索过滤技术1234567891011121314151617&lt;input type=&quot;search&quot; id=&quot;input&quot; placeholder=&quot;输入城市名称或拼音&quot; /&gt;&lt;ul&gt; &lt;li data-search=&quot;重庆市chongqing&quot;&gt;重庆市&lt;/li&gt; &lt;li data-search=&quot;哈尔滨市haerbing&quot;&gt;哈尔滨市&lt;/li&gt; &lt;li data-search=&quot;长春市changchun&quot;&gt;长春市&lt;/li&gt; ...&lt;/ul&gt;//jsvar eleStyle = document.createElement(&#x27;style&#x27;);document.head.appendChild(eleStyle);// 文本框输入input.addEventListener(&quot;input&quot;, function() &#123; var value = this.value.trim(); eleStyle.innerHTML = value ? &#x27;[data-search]:not([data-search*=&quot;&#x27;+ value +&#x27;&quot;]) &#123; display: none; &#125;&#x27; : &#x27;&#x27;;&#125;); 6.4忽略属性值大小写的正则匹配运算符使用字符i或I作为运算符，可以忽略属性值大小写。 7 用户行为伪类7.1 手型经过伪类:hover 不适用于移动端 在桌面端很常用 7.1.1 体验优化与:hover延时123456789101112131415161718192021222324252627&lt;table&gt; &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;标题1&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;标题2&lt;/th&gt; &lt;th scope=&quot;col&quot; width=&quot;40&quot;&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容1&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;td&gt;&lt;a href class=&quot;icon-delete&quot; data-title=&quot;删除&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容3&lt;/td&gt; &lt;td&gt;内容4&lt;/td&gt; &lt;td&gt;&lt;a href class=&quot;icon-delete&quot; data-title=&quot;删除&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;.icon-delete::before,.icon-delete::after &#123; transition: visibility 0s .2s; visibility: hidden;&#125;.icon-delete:hover::before,.icon-delete:hover::after &#123; visibility: visible;&#125; 7.1.2 非子元素的:hover显示123456789101112&lt;a href&gt;图片链接&lt;/a&gt;&lt;img src=&quot;1.jpg&quot;&gt;img &#123; display: none; position: absolute; z-index: 1;&#125;a:hover + img,img:hover &#123; display: inline;&#125; transition对display无过渡效果，对visibility有过渡效果 7.1.3 纯:hover显示浮层的体验问题使用:focus避免用户没有鼠标，无法触发:hover的情况 7.2激活状态伪类:active7.2.1:active伪类概述7.2.2按钮的通用:active样式技巧 适用于移动端开发 使用box-shadow处理反馈 使用线性渐变linear-gradient 7.3焦点伪类:focus7.3.1:focus伪类匹配机制只能匹配特定的元素，如 非disable状态的表单元素，如&lt;input&gt;输入框，&lt;select&gt;下拉框，&lt;button&gt;按钮 包含&lt;herf&gt;的&lt;a&gt;元素 &lt;summary&gt; &lt;area&gt; 7.3.2:focus伪类与outline设置ontline:none后，最好添加一个样式，如border-color:HighLight,防止用户使用键盘输入时没有响应。 7.3.3 CSS:focus伪类与键盘无障碍访问7.4整体焦点伪类:focus-within7.4.1 :focus-within和:focus伪类的区别:focus：当前元素处于聚焦样式才会匹配 :focus-within：当前元素或任意子元素处于聚焦样式会匹配 7.4.2 :focus-within实现无障碍访问的下拉列表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;div class=&quot;cs-bar&quot;&gt; &lt;div class=&quot;cs-details&quot;&gt; &lt;a href=&quot;javascript:&quot; class=&quot;cs-summary&quot;&gt;我的消息&lt;/a&gt; &lt;div class=&quot;cs-datalist&quot;&gt; &lt;a href class=&quot;cs-datalist-a&quot;&gt;我的回答&lt;sup class=&quot;cs-datalist-sup&quot;&gt;12&lt;/sup&gt;&lt;/a&gt; &lt;a href class=&quot;cs-datalist-a&quot;&gt;我的私信&lt;/a&gt; &lt;a href class=&quot;cs-datalist-a&quot;&gt;未评价订单&lt;sup class=&quot;cs-datalist-sup&quot;&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;a href class=&quot;cs-datalist-a&quot;&gt;我的关注&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.cs-bar &#123; background-color: #e3e4e5; color: #888; padding-left: 40px;&#125;.cs-details &#123; display: inline-block; text-align: left;&#125;.cs-summary &#123; display: inline-block; padding: 5px 28px; text-indent: -15px; user-select: none; position: relative; z-index: 1;&#125;.cs-summary::after &#123; content: &quot;&quot;; position: absolute; width: 12px; height: 12px; margin: 4px 0 0 .5ch; background: url(./icon-arrow.svg) no-repeat; background-size: 100% 100%; transition: transform .2s;&#125;.cs-details:focus-within .cs-summary,.cs-summary:hover &#123; background-color: #fff; box-shadow: inset 1px 0 #ddd, inset -1px 0 #ddd;&#125;.cs-details:focus-within .cs-summary::after &#123; transform: rotate(180deg);&#125;.cs-datalist &#123; display: none; position: absolute; min-width: 100px; border: 1px solid #ddd; background-color: #fff; margin-top: -1px;&#125;.cs-details:focus-within .cs-datalist &#123; display: block;&#125;.cs-datalist-a &#123; display: block; padding: 5px 10px; transition: background-color .2s, color .2s; color: inherit;&#125;.cs-datalist-a:hover &#123; background-color: #f5f5f5;&#125;.cs-datalist-a:active &#123; background-color: #f0f0f0; color: #555;&#125;.cs-datalist-sup &#123; position: absolute; color: #cd0000; font-size: 12px; margin-top: -.25em; margin-left: 2px;&#125;&lt;/style&gt; 7.5键盘焦点伪类:focus-visible鼠标访问时不会有焦点轮廓，但键盘tab键访问时会有。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt;.cs-button &#123; background-color: teal; color: #fff; border: 0; padding: .75em 2em;&#125;.focus-better :focus:not(:focus-visible) &#123; outline: 0;&#125;&lt;/style&gt;&lt;h4&gt;原始状态（点击访问）&lt;/h4&gt;&lt;ol class=&quot;demical&quot;&gt; &lt;li&gt;&lt;button class=&quot;cs-button&quot;&gt;按钮&lt;/button&gt;&lt;/li&gt; &lt;li&gt; &lt;details&gt; &lt;summary&gt;summary元素&lt;/summary&gt; &lt;p&gt;Chrome浏览器下点击会出现焦点轮廓。&lt;/p&gt; &lt;/details&gt; &lt;/li&gt; &lt;li&gt; &lt;div tabindex=&quot;0&quot;&gt;我是设置了&lt;code&gt;tabindex=&quot;0&quot;&lt;/code&gt;的普通div元素。&lt;/div&gt; &lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;:focus-visible优化后（Tab键访问）&lt;/h4&gt;&lt;ol class=&quot;demical focus-better&quot;&gt; &lt;li&gt;&lt;button class=&quot;cs-button&quot;&gt;按钮&lt;/button&gt;&lt;/li&gt; &lt;li&gt; &lt;details&gt; &lt;summary&gt;summary元素&lt;/summary&gt; &lt;p&gt;Chrome浏览器下点击不会出现焦点轮廓。&lt;/p&gt; &lt;/details&gt; &lt;/li&gt; &lt;li&gt; &lt;div tabindex=&quot;0&quot;&gt;我是设置了&lt;code&gt;tabindex=&quot;0&quot;&lt;/code&gt;的普通div元素。&lt;/div&gt; &lt;/li&gt;&lt;/ol&gt; 8 URL定位伪类8.1链接历史伪类:link和:visited8.1.1深入理解:link:link匹配页面上链接没有访问过的&lt;a&gt;元素 8.1.2 怪癖最多的CSS伪类:visited 支持的CSS属性有限 支持子选择器 没有半透明 只能重置，不能凭空设置 12345678&lt;a href&gt;link&lt;/a&gt;/*不会出现背景色*/a&#123;color:blue&#125;a:visited&#123;color:red;background:grey&#125;/*会出现背景色*/a&#123;color:blue;background:write&#125;a:visited&#123;color:red;background:grey&#125; 无法获取：visited的设置和呈现的色值 8.2超链接伪类:any-link 匹配所有设置了href的链接元素 匹配所有匹配:link :visited 的元素 8.3目标伪类:target8.3.1:target与锚点8.3.2:target交互布局技术简介8.4目标容器伪类:target-within9 输入伪类9.1输入控件状态9.1.1可用状态与禁用状态伪类:enabled和:disabled9.1.2读写特性伪类:read-only和:read-write9.1.3占位符显示伪类:placeholder-shown9.1.4默认选项伪类:default9.2 输入值状态与单选框和复选框相关： 1&lt;input type&#x3D;&quot;radio&quot;&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt; 9.2.1选中选项伪类:checked123456input:checked&#123;//定义样式box-shadow:0 0 0 2px red;&#125;&lt;input type=&quot;checkbox&quot;&gt;&lt;input type=&quot;checkbox &quot; checked&gt; 相当于 input[checked]&#123;box-shadow:0 0 0 2px red;&#125; 9.2.2不确定值伪类:indeterminate复选框半选示例 复选框提示未选择示例 9.3输入值验证9.3.1有效性验证伪类:valid和:invalid9.3.2 范围验证伪类:in-range 和:out-of-range9.3.3可选性伪类:required和:optional9.3.4用户交互伪类:user-invalid和空值伪类:blank10 树结构伪类10.1:root伪类10.1.1:root伪类和&lt;html&gt;元素root伪类表示文档根元素 10.1.2:root伪类的应用场景 滚动条出现时页面不跳动 12345678910111213/*IE 8*/html&#123;overflow-y:scroll;&#125;/*IE 9+*/:root&#123;overflow-x:hidden;&#125;:root body&#123;position :absolute;width: 100vw;overflow:hidden;&#125; 定义CSS变量 10.2:empty伪类匹配空标签元素 匹配前后闭合的替换元素 匹配非闭合元素 10.2.1对:empty伪类可能的误解 元素内有注释则不匹配 元素内有空格或标签或换行则不匹配 元素内有注释则不匹配 10.2.2超实用超高频使用的:empty伪类 字段缺失智能提示 10.3 子索引伪类10.3.1 :first-child伪类和:last-child伪类:first-child伪类匹配第一个子元素 :last-child伪类匹配最后一个子元素 10.3.2 :only-child伪类匹配没有任何兄弟的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 1. 只有加载图片 --&gt;&lt;div class=&quot;cs-loading&quot;&gt; &lt;img src=&quot;./loading.png&quot; class=&quot;cs-loading-img&quot;&gt;&lt;/div&gt;&lt;!-- 2. 只有加载文字 --&gt;&lt;div class=&quot;cs-loading&quot;&gt; &lt;p class=&quot;cs-loading-p&quot;&gt;正在加载中...&lt;/p&gt;&lt;/div&gt;&lt;!-- 3. 加载图片和加载文字同时存在 --&gt;&lt;div class=&quot;cs-loading&quot;&gt; &lt;img src=&quot;./loading.png&quot; class=&quot;cs-loading-img&quot;&gt; &lt;p class=&quot;cs-loading-p&quot;&gt;正在加载中...&lt;/p&gt;&lt;/div&gt;&lt;style&gt;.cs-loading &#123; height: 150px; position: relative; text-align: center; /* 与截图无关，截图示意用 */ border: 1px dotted;&#125;/* 图片和文字同时存在时在中间留点间距 */.cs-loading-img &#123; width: 32px; height: 32px; margin-top: 45px; vertical-align: bottom;&#125;.cs-loading-p &#123; margin: .5em 0 0; color: gray;&#125;/* 只有图片的时候居中绝对定位 */.cs-loading-img:only-child &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;&#125;/* 只有文字的时候行号近似垂直居中 */.cs-loading-p:only-child &#123; margin: 0; line-height: 150px;&#125;&lt;/style&gt; 10.3.3 :nth-child()伪类和:nth-last-child()伪类 :nth-child()伪类 从前面开始匹配 :nth-last-child()伪类 从后面开始匹配 下面来看一些示例，快速了解一下各种类型的参数的含义。tr:nth-child(odd):匹配表格的第1,3,5行，等同于tr:nth-child(2n+1)。 tr:nth-child (even):匹配表格的第2,4,6行，等同于tr:nth-child(2n)。 :nth-child(3):匹配第3个元素。:nth-child(5n):匹配第5,10,15,..个元素。其中5=5x1，10=5x2，15=5x3 :nth-child(3n+4):匹配第4,7，10,.个元素。其中4=(3x0)+4，7=(3x1)+4， 10=(3x2)+4.. :nth-child(-n+3):匹配前3个元素。因为-0+3=3，-1+3=2，-2+3-1. li:nth-child(n):匹配所有的&lt;1i&gt;元素，就匹配的元素而言和li标签选择器一 模一样，区别就是优先级更高了。实际开发总是避免过高的优先级，因此没有任何理 由这么使用。li:nth-child(1):匹配第一个元素，和li:first-child匹配的作用一样， 区别就是后者的兼容性更好，因此，也没有任何这么使用的理由，使用:first-child 代替它。li:nth-child(n+4):nth-child(-n+10):匹配第4~10个&lt;li&gt;元素，这个就 属于比较高级的用法了。例如，考试成绩是前3名的有徽章，第4名到第10名高亮显 示，此时，这种正负值组合的伪类就非常好用。 10.4匹配类型的子索引伪类10.4.1 :first-of-type伪类和:last-of-type伪类 :first-of-type 匹配当前标签类型元素的第一个 :last-of-type伪类 匹配当前标签类型元素的最后一个 10.4.2 :only-of-type伪类 :only-of-type伪类 匹配唯一的标签类型元素 10.4.3 :nth-of-type()伪类和:nth-last-of-type()伪类 :nth-of-type()伪类 匹配指定索引的当前标签元素 11 逻辑组合伪类11.1否定伪类:not()匹配与括号内的选择器匹配不上的元素，如 :not(p) 匹配不是&lt;p&gt;的元素 可以不断级联，如input:not(disable):not(read-only)&#123;&#125; 11.2了解任意匹配伪类:is()11.2.1 :is()伪类与:matches()伪类及:any()伪类之间的关系11.2.2 :is()伪类的语法与作用11.3了解任意匹配伪类:where()11.4了解关联伪类:has()12 其他伪类选择器12.1与作用域相关的伪类12.1.1参考元素伪类:scope12.1.2 Shadow树根元素伪类:host12.1.3 Shadow树根元素匹配伪类:host()12.1.4 Shadow树根元素上下文匹配伪类:host-context().12.2与全屏相关的伪类 :fullscreen12.3 了解语言相关伪类12.3.1 方向伪类:dir()12.3.2 语言伪类:lang()12.4 了解资源状态伪类","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"author":"YukiXueyan"},{"title":"正则表达式","slug":"正则表达式","date":"2021-02-02T09:14:53.000Z","updated":"2021-03-15T12:57:41.561Z","comments":true,"path":"2021/02/02/正则表达式/","link":"","permalink":"http://example.com/2021/02/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式网址https://regexr.com 1. 匹配任意字符基本格式([A-Z])\\w+ 匹配随意一个字符串str 匹配“王XX”王.. .：匹配除断行外任意一个字符，\\.匹配“.”这一个字符 转义符\\ 2. 匹配字母和数字\\w：匹配字母、数字、下划线 \\W：匹配被\\w排除的东西（\\w的补集） 3. 匹配数字\\d：匹配阿拉伯数字 \\D: 匹配非阿拉伯数字（\\d的补集） 4. 匹配空白字符\\s:匹配空白字符:空格、制表符、断行等 \\S(\\s的补集） 5. 字符集合[abc]只匹配abc这三个字符（不包含大写） [a-z] 匹配从a到z的字符 用Unicode匹配中文字符 （graphemica网站：输入Unicode字符显示中文字符） [选择范围] 匹配括号中的任意一个字符 6. 重复[范围]+重复一次或多次e.g: [yY][oO]+匹配yo,Yo,yooo,YO等字符串 [范围]*重复零次或多次 [范围]？重复零个或一个 指定重复范围&#123;a,b&#125;匹配重复范围在a到b次 &#123;a,b&#125;\\b只匹配重复范围在a到b次的字符串，超过的就不匹配了 \\b边界 &#123;a&#125;匹配重复a次的字符串（不到a次的不会匹配到 &#123;a,&#125;匹配重复范围为a次以上 7. 分组匹配(.+)(.+) $1表示第一组，以此类推 abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。 [^abc]匹配除abc外的所有字符 [\\s\\S]匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，包括换行。 特别字符 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 修饰符 修饰符 含义 描述 i ignore - 不区分大小写 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 g global - 全局匹配 查找所有的匹配项。 m multi line - 多行匹配 使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 s 特殊字符圆点 . 中包含换行符 \\n 默认情况下的圆点 . 是 匹配除换行符 \\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\n。 123456var str&#x3D;&quot;Google runoob taobao runoob&quot;; var n1&#x3D;str.match(&#x2F;runoob&#x2F;); &#x2F;&#x2F; 查找第一次匹配项var n2&#x3D;str.match(&#x2F;runoob&#x2F;g); &#x2F;&#x2F; 查找所有匹配项var n2&#x3D;str.match(&#x2F;runoob&#x2F;gi); &#x2F;&#x2F; 不区分大小写var n2&#x3D;str.match(&#x2F;^runoob&#x2F;gm); &#x2F;&#x2F; 多行匹配 示例 正则表达式 描述 /\\b([a-z]+) \\1\\b/gi 一个单词连续出现的位置。 /(\\w+)://([^/:]+)(:\\d*)?([^# ]*)/ 将一个URL解析为协议、域、端口及相对路径。 /^(?:Chapter|Section) [1-9][0-9]{0,1}$/ 定位章节的位置。 /[-a-z]/ a至z共26个字母再加一个-号。 /ter\\b/ 可匹配chapter，而不能匹配terminal。 /\\Bapt/ 可匹配chapter，而不能匹配aptitude。 /Windows(?=95 |98 |NT )/ 可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。 /^\\s*$/ 匹配空行。 /\\d{2}-\\d{5}/ 验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。 /&lt;\\s*(\\S+)(\\s[^&gt;])?&gt;[\\s\\S]&lt;\\s*/\\1\\s*&gt;/ 匹配 HTML 标记。","categories":[{"name":"学习日记","slug":"学习日记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"author":"YukiXueyan"},{"title":"VueStudy","slug":"VueStudy","date":"2021-02-02T08:23:13.000Z","updated":"2021-03-24T07:36:32.796Z","comments":true,"path":"2021/02/02/VueStudy/","link":"","permalink":"http://example.com/2021/02/02/VueStudy/","excerpt":"","text":"vue.js 介绍vue官方文档 vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。 引入&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; vue-cli 工程化构建 Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统 所有东西都是响应式的。可以实时修改并更新 条件与循环 v-if=&quot;seen&quot;控制一个元素是否显示 123456789&lt;div id=&quot;app-3&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt;var app3 = new Vue(&#123; el: &#x27;#app-3&#x27;, data: &#123; seen: true &#125;&#125;) 不仅可以把数据绑定到 DOM 文本或 attribute，还可以绑定到 DOM 结构 v-for 指令可以绑定数组的数据来渲染一个项目列表 1234567891011121314151617&lt;div id=&quot;app-4&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;var app4 = new Vue(&#123; el: &#x27;#app-4&#x27;, data: &#123; todos: [ &#123; text: &#x27;学习 JavaScript&#x27; &#125;, &#123; text: &#x27;学习 Vue&#x27; &#125;, &#123; text: &#x27;整个牛项目&#x27; &#125; ] &#125;&#125;) v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法 123456789101112131415&lt;div id&#x3D;&quot;app-5&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt; &lt;button v-on:click&#x3D;&quot;reverseMessage&quot;&gt;反转消息&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;var app5 &#x3D; new Vue(&#123; el: &#39;#app-5&#39;, data: &#123; message: &#39;Hello Vue.js!&#39; &#125;, methods: &#123; reverseMessage: function () &#123; this.message &#x3D; this.message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125; &#125;&#125;) v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定 12345678910&lt;div id=&quot;app-6&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app6 = new Vue(&#123; el: &#x27;#app-6&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;&#125;) …. 组件化组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。 123456789101112&#x2F;&#x2F; 定义名为 todo-item 的新组件Vue.component(&#39;todo-item&#39;, &#123; template: &#39;&lt;li&gt;这是个待办项&lt;&#x2F;li&gt;&#39;&#125;)var app &#x3D; new Vue(...)现在你可以用它构建另一个组件模板：&lt;ol&gt; &lt;!-- 创建一个 todo-item 组件的实例 --&gt; &lt;todo-item&gt;&lt;&#x2F;todo-item&gt;&lt;&#x2F;ol&gt; prop——从父作用域将数据传到子组件 1234567Vue.component(&#39;todo-item&#39;, &#123; &#x2F;&#x2F; todo-item 组件现在接受一个 &#x2F;&#x2F; &quot;prop&quot;，类似于一个自定义 attribute。 &#x2F;&#x2F; 这个 prop 名为 todo。 props: [&#39;todo&#39;], template: &#39;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;&#x2F;li&gt;&#39;&#125;) v-bind 指令将待办项传到循环输出的每个组件中 123456789101112131415161718192021222324252627282930&lt;div id=&quot;app-7&quot;&gt; &lt;ol&gt; &lt;!-- 现在我们为每个 todo-item 提供 todo 对象 todo 对象是变量，即其内容可以是动态的。 我们也需要为每个组件提供一个“key”，稍后再 作详细解释。 --&gt; &lt;todo-item v-for=&quot;item in groceryList&quot; v-bind:todo=&quot;item&quot; v-bind:key=&quot;item.id&quot; &gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt;Vue.component(&#x27;todo-item&#x27;, &#123; props: [&#x27;todo&#x27;], template: &#x27;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&#x27;&#125;)var app7 = new Vue(&#123; el: &#x27;#app-7&#x27;, data: &#123; groceryList: [ &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;, &#123; id: 1, text: &#x27;奶酪&#x27; &#125;, &#123; id: 2, text: &#x27;随便其它什么人吃的东西&#x27; &#125; ] &#125;&#125;) 实例数据与方法 只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。 使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。 123456789101112131415var obj = &#123; foo: &#x27;bar&#x27;&#125;Object.freeze(obj)new Vue(&#123; el: &#x27;#app&#x27;, data: obj&#125;)&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;!-- 这里的 `foo` 不会更新！ --&gt; &lt;button v-on:click=&quot;foo = &#x27;baz&#x27;&quot;&gt;Change it&lt;/button&gt;&lt;/div&gt; … 实例生命周期钩子 模板语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。 在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。 插值 文本-数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-html输出真正的HTML 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。 v-bind 绑定属性 &lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 双括号还可以使用JavaScript表达式 计算属性和侦听器板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： 123&lt;div id&#x3D;&quot;example&quot;&gt; &#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;&lt;&#x2F;div&gt; 在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。想要在模板中的多处包含此翻转字符串时，就会更加难以处理。 所以，对于任何复杂逻辑，都应当使用计算属性。 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖： 12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 计算属性 VS 侦听属性class与style绑定操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 条件渲染v-if vs v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 不推荐同时使用 v-if 和 v-for当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下： 123&lt;li v-for&#x3D;&quot;todo in todos&quot; v-if&#x3D;&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125;&lt;&#x2F;li&gt; 上面的代码将只渲染未完成的 todo。 而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 [`) 上。如： 123456&lt;ul v-if&#x3D;&quot;todos.length&quot;&gt; &lt;li v-for&#x3D;&quot;todo in todos&quot;&gt; &#123;&#123; todo &#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;p v-else&gt;No todos left!&lt;&#x2F;p&gt; https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81 列表渲染用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。 在 v-for 块中，我们可以访问所有父作用域的 property。v-for 还支持一个可选的第二个参数，即当前项的索引。 可以用 v-for 来遍历一个对象的 property。 123456789101112131415&lt;ul id&#x3D;&quot;v-for-object&quot; class&#x3D;&quot;demo&quot;&gt; &lt;li v-for&#x3D;&quot;value in object&quot;&gt; &#123;&#123; value &#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;new Vue(&#123; el: &#39;#v-for-object&#39;, data: &#123; object: &#123; title: &#39;How to do lists in Vue&#39;, author: &#39;Jane Doe&#39;, publishedAt: &#39;2016-04-10&#39; &#125; &#125;&#125;) 事件处理可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。 示例： 12345678910&lt;div id&#x3D;&quot;example-1&quot;&gt; &lt;button v-on:click&#x3D;&quot;counter +&#x3D; 1&quot;&gt;Add 1&lt;&#x2F;button&gt; &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;var example1 &#x3D; new Vue(&#123; el: &#39;#example-1&#39;, data: &#123; counter: 0 &#125;&#125;) 结果： Add 1 The button above has been clicked 0 times. 事件处理方法然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。 示例： 123456789101112131415161718192021222324&lt;div id&#x3D;&quot;example-2&quot;&gt; &lt;!-- &#96;greet&#96; 是在下面定义的方法名 --&gt; &lt;button v-on:click&#x3D;&quot;greet&quot;&gt;Greet&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;var example2 &#x3D; new Vue(&#123; el: &#39;#example-2&#39;, data: &#123; name: &#39;Vue.js&#39; &#125;, &#x2F;&#x2F; 在 &#96;methods&#96; 对象中定义方法 methods: &#123; greet: function (event) &#123; &#x2F;&#x2F; &#96;this&#96; 在方法里指向当前 Vue 实例 alert(&#39;Hello &#39; + this.name + &#39;!&#39;) &#x2F;&#x2F; &#96;event&#96; 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)&#x2F;&#x2F; 也可以用 JavaScript 直接调用方法example2.greet() &#x2F;&#x2F; &#x3D;&gt; &#39;Hello Vue.js!&#39; 结果： Greet 内联处理器中的方法除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法： 123456789101112&lt;div id&#x3D;&quot;example-3&quot;&gt; &lt;button v-on:click&#x3D;&quot;say(&#39;hi&#39;)&quot;&gt;Say hi&lt;&#x2F;button&gt; &lt;button v-on:click&#x3D;&quot;say(&#39;what&#39;)&quot;&gt;Say what&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;new Vue(&#123; el: &#39;#example-3&#39;, methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;) 结果： Say hi Say what 有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法： 12345678910111213&lt;button v-on:click&#x3D;&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;&gt; Submit&lt;&#x2F;button&gt;&#x2F;&#x2F; ...methods: &#123; warn: function (message, event) &#123; &#x2F;&#x2F; 现在我们可以访问原生事件对象 if (event) &#123; event.preventDefault() &#125; alert(message) &#125;&#125; 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive 12345678910111213141516171819&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 2.1.4 新增 12&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt; 不像其它只能对原生的 DOM 事件起作用的修饰符，.once 修饰符还能被用到自定义的组件事件上。如果你还没有阅读关于组件的文档，现在大可不必担心。 2.3.0 新增 Vue 还对应 addEventListener 中的 passive 选项提供了 .passive 修饰符。 1234&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 &#96;onScroll&#96; 完成 --&gt;&lt;!-- 这其中包含 &#96;event.preventDefault()&#96; 的情况 --&gt;&lt;div v-on:scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt; 这个 .passive 修饰符尤其能够提升移动端的性能。 不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。 按键修饰符在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 &#96;key&#96; 是 &#96;Enter&#96; 时调用 &#96;vm.submit()&#96; --&gt;&lt;input v-on:keyup.enter&#x3D;&quot;submit&quot;&gt; 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。 1&lt;input v-on:keyup.page-down&#x3D;&quot;onPageDown&quot;&gt; 在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。 按键码keyCode 的事件用法已经被废弃了并可能不会被最新的浏览器支持。 使用 keyCode attribute 也是允许的： 1&lt;input v-on:keyup.13&#x3D;&quot;submit&quot;&gt; 为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，这些内置的别名应该是首选。 你还可以通过全局 config.keyCodes 对象自定义按键修饰符别名： 12&#x2F;&#x2F; 可以使用 &#96;v-on:keyup.f1&#96;Vue.config.keyCodes.f1 &#x3D; 112 系统修饰键 2.1.0 新增 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta 注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。 例如： 12345&lt;!-- Alt + C --&gt;&lt;input v-on:keyup.alt.67&#x3D;&quot;clear&quot;&gt;&lt;!-- Ctrl + Click --&gt;&lt;div v-on:click.ctrl&#x3D;&quot;doSomething&quot;&gt;Do something&lt;&#x2F;div&gt; 请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。 .exact 修饰符 2.5.0 新增 .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button v-on:click.ctrl&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button v-on:click.ctrl.exact&#x3D;&quot;onCtrlClick&quot;&gt;A&lt;&#x2F;button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button v-on:click.exact&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt; 鼠标按钮修饰符 2.2.0 新增 .left .right .middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 为什么在 HTML 中监听事件？你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处： 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。 表单输入绑定用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。 v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 组件基础data一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： 12345data: function () &#123; return &#123; count: 0 &#125;&#125; 如果 Vue 没有这条规则，点击一个按钮就可能会像如下代码一样影响到其它所有实例 组件注册prop自定义事件插槽动态组件、异步组件边界情况过渡","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}],"author":"YukiXueyan"},{"title":"0131Study","slug":"0131Study","date":"2021-02-02T08:19:29.000Z","updated":"2021-02-08T04:44:20.494Z","comments":true,"path":"2021/02/02/0131Study/","link":"","permalink":"http://example.com/2021/02/02/0131Study/","excerpt":"","text":"互联网是如何工作的电脑之间需要通信，就需要进行连接。在有多个电脑时，电脑会先与路由器进行连接，将数据传输到路由器，路由器再分配数据到另一台电脑。 路由器之间也可以互相连接。 为了连接电话这种网络我们需要一种基础设备叫做调制解调器（modem），调制解调器可以把网络信息变成电话设施可以处理的信息，反之亦然。 把我们的网络连接到互联网服务提供商（ISP）。ISP是一家可以管理一些特殊的路由器的公司，这些路由器连接其他ISP的路由器. 你的网络消息可以被ISP捕获并发送到相应的网络。互联网就是由这些所有的网络设施所组成。 通过IP地址寻找到目标网络。 浏览器的工作原理浏览器的工作原理 编辑器编辑器就首推VS Code啦 1、工作区快捷键 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Shift + P Ctrl + Shift + P，F1 显示命令面板 Cmd + B Ctrl + B 显示/隐藏侧边栏 很实用 Cmd + \\ Ctrl + \\ 创建多个编辑器 【重要】抄代码利器 Cmd + 1、2 Ctrl + 1、2 聚焦到第 1、第 2 个编辑器 同上重要 cmd +/- ctrl +/- 将工作区放大/缩小（包括代码字体、左侧导航栏） 在投影仪场景经常用到 Cmd + J Ctrl + J 显示/隐藏控制台 Cmd + Shift + N Ctrl + Shift + N 重新开一个软件的窗口 很常用 Cmd + Shift + W Ctrl + Shift + W 关闭软件的当前窗口 Cmd + N Ctrl + N 新建文件 Cmd + W Ctrl + W 关闭当前文件 2、跳转操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + ` 没有 在同一个软件的多个工作区之间切换 使用很频繁 Cmd + Option + 左右方向键 Ctrl + Pagedown/Pageup 在已经打开的多个文件之间进行切换 非常实用 Ctrl + Tab Ctrl + Tab 在已经打开的多个文件之间进行跳转 不如上面的快捷键快 Cmd + Shift + O Ctrl + shift + O 在当前文件的各种方法之间进行跳转 Ctrl + G Ctrl + G 跳转到指定行 Cmd+Shift+\\ Ctrl+Shift+\\ 跳转到匹配的括号 3、移动光标 Mac 快捷键 Win 快捷键 作用 备注 方向键 方向键 在单个字符之间移动光标 大家都知道 option + 左右方向键 Ctrl + 左右方向键 在单词之间移动光标 很常用 Cmd + 左右方向键 Fn + 左右方向键 在整行之间移动光标 很常用 Cmd + ← Fn + ←（或 Win + ←） 将光标定位到当前行的最左侧 很常用 Cmd + → Fn + →（或 Win + →） 将光标定位到当前行的最右侧 很常用 Cmd + ↑ Ctrl + Home 将光标定位到文章的第一行 Cmd + ↓ Ctrl + End 将光标定位到文章的最后一行 Cmd + Shift + \\ 在代码块之间移动光标 4、编辑操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Enter Ctrl + Enter 在当前行的下方新增一行，然后跳至该行 即使光标不在行尾，也能快速向下插入一行 Cmd+Shift+Enter Ctrl+Shift+Enter 在当前行的上方新增一行，然后跳至该行 即使光标不在行尾，也能快速向上插入一行 Option + ↑ Alt + ↑ 将代码向上移动 很常用 Option + ↓ Alt + ↓ 将代码向下移动 很常用 Option + Shift + ↑ Alt + Shift + ↑ 将代码向上复制 Option + Shift + ↓ Alt + Shift + ↓ 将代码向下复制 写重复代码的利器 5、多光标编辑 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Option + 上下键 Ctrl + Alt + 上下键 在连续的多列上，同时出现光标 Option + 鼠标点击任意位置 Alt + 鼠标点击任意位置 在任意位置，同时出现光标 Option + Shift + 鼠标拖动 Alt + Shift + 鼠标拖动 在选中区域的每一行末尾，出现光标 Cmd + Shift + L Ctrl + Shift + L 在选中文本的所有相同内容处，出现光标 其他的多光标编辑操作：（很重要） 选中某个文本，然后反复按住快捷键「 Cmd + D 」键（windows 用户是按住「Ctrl + D」键）， 即可将全文中相同的词逐一加入选择。 选中一堆文本后，按住「Option + Shift + i」键（windows 用户是按住「Alt + Shift + I」键），既可在每一行的末尾都创建一个光标。 6、删除操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + shift + K Ctrl + Shift + K 删除整行 「Cmd + X」的作用是剪切，但也可以删除整行 option + Backspace Ctrl + Backspace 删除光标之前的一个单词 英文有效，很常用 option + delete Ctrl + delete 删除光标之后的一个单词 Cmd + Backspace 删除光标之前的整行内容 很常用 Cmd + delete 删除光标之后的整行内容 备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。 7、编程语言相关 Mac 快捷键 Win 快捷键 作用 备注 Cmd + / Ctrl + / 添加单行注释 很常用 Option + Shift + F Alt + shift + F 代码格式化 很常用 F2 F2 以重构的方式进行重命名 改代码备 Ctrl + J 将多行代码合并为一行 Win 用户可在命令面板搜索”合并行“ Cmd + Cmd + U Ctrl + U 将光标的移动回退到上一个位置 撤销光标的移动和选择 8、搜索相关 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Shift + F Ctrl + Shift +F 全局搜索代码 很常用 Cmd + P Ctrl + P 在当前的项目工程里，全局搜索文件名 Cmd + F Ctrl + F 在当前文件中搜索代码，光标在搜索框里 Cmd + G F3 在当前文件中搜索代码，光标仍停留在编辑器里 很巧妙 快捷键速查表[官方]：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf VS Code的使用 JavaScriptES6教程-阮一峰 现代 JavaScript 教程","categories":[{"name":"学习日记","slug":"学习日记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Diary","slug":"Diary","permalink":"http://example.com/tags/Diary/"}],"author":"YukiXueyan"},{"title":"GitStudy","slug":"GitStudy","date":"2021-02-02T08:16:08.000Z","updated":"2021-02-08T04:44:06.051Z","comments":true,"path":"2021/02/02/GitStudy/","link":"","permalink":"http://example.com/2021/02/02/GitStudy/","excerpt":"","text":"Git的常用命令初始化配置用户名和邮箱 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; git init命令把目录变成Git可以管理的仓库 git add &lt;文件名&gt;将文件添加到仓库 git commit提交 ：git commit -m &quot;xxx&quot; git status 查看仓库当前状态 git diff 查看具体修改 git log命令查看修改历史 git reset --hard HEAD^回退到上一个版本 git reset --hard commit_id git reflog 查看历史所有命令 git checkout -- file可以丢弃工作区的修改 git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（只是add，没有commit） 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 git remote add origin git@github.com:&lt;username&gt;/&lt;仓库名&gt;.git 本地仓库与远程仓库连接 git push -u origin master 第一次推送本地仓库内容到远程仓库 git push origin master 推送本地仓库内容到远程仓库 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 用git log --graph命令可以看到分支合并图。 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 git tag &lt;name&gt;就可以打一个新标签 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}],"author":"YukiXueyan"},{"title":"hexoNote","slug":"hexoNote","date":"2021-02-02T07:45:00.000Z","updated":"2021-02-08T04:44:13.047Z","comments":true,"path":"2021/02/02/hexoNote/","link":"","permalink":"http://example.com/2021/02/02/hexoNote/","excerpt":"","text":"hexo快捷命令 hexo new 文章名创建新文章hexo clean 清除缓存hexo g重新配置hexo s在本地运行，查看bloghexo d将博客推送到远程","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://example.com/tags/blog/"}],"author":"YukiXueyan"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"},{"name":"android","slug":"android","permalink":"http://example.com/categories/android/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"},{"name":"学习日记","slug":"学习日记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"android","slug":"android","permalink":"http://example.com/tags/android/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Diary","slug":"Diary","permalink":"http://example.com/tags/Diary/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://example.com/tags/blog/"}]}